<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Natal Chart Generator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: system-ui, sans-serif;
  background-color: #f5f0e6;
  background-image:
    linear-gradient(rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(rgba(180,172,158,0.10) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(180,172,158,0.10) 0.5px, transparent 0.5px);
  background-size:
    100px 100px,
    100px 100px,
    20px 20px,
    20px 20px;
  color: #2c2c2c;
  display: flex;
  height: 100vh;
  overflow: hidden;
}
#controls {
  width: 320px;
  min-width: 320px;
  background: rgba(237,232,222,0.85);
  border-right: 1px solid #d4cfc5;
  padding: 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
#controls h2 {
  font-size: 16px;
  color: #3a3630;
  margin-bottom: 4px;
}
.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  position: relative;
}
.form-group label {
  font-size: 12px;
  color: #7a7568;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
input[type="text"] {
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 8px 10px;
  border-radius: 4px;
  font-size: 14px;
  font-family: system-ui, sans-serif;
  outline: none;
}
input[type="text"]:focus { border-color: #8b7d6b; }
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: #d4cfc5;
  border-radius: 2px;
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border-radius: 50%;
  cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border: none;
  border-radius: 50%;
  cursor: pointer;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.slider-row input[type="range"] { flex: 1; }
.slider-value {
  font-size: 13px;
  color: #3a3630;
  min-width: 36px;
  text-align: right;
  font-variant-numeric: tabular-nums;
}
.time-row {
  display: flex;
  gap: 8px;
}
.time-row select {
  flex: 1;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 13px;
  font-family: system-ui, sans-serif;
  outline: none;
}
.time-row select:focus { border-color: #8b7d6b; }
.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  border-top: none;
  border-radius: 0 0 4px 4px;
  z-index: 100;
  display: none;
  max-height: 200px;
  overflow-y: auto;
}
.dropdown.open { display: block; }
.dropdown-item {
  padding: 8px 10px;
  font-size: 13px;
  cursor: pointer;
  border-bottom: 1px solid #ede8de;
}
.dropdown-item:hover { background: #ede8de; }
.location-display {
  font-size: 11px;
  color: #7a7568;
  margin-top: 2px;
}
#error {
  color: #c0392b;
  font-size: 13px;
  display: none;
}
#results {
  display: none;
  flex: 1;
  overflow-y: auto;
}
#results h3 {
  font-size: 13px;
  color: #3a3630;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#planet-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
#planet-table th {
  text-align: left;
  padding: 4px 6px;
  border-bottom: 1px solid #d4cfc5;
  color: #7a7568;
  font-weight: normal;
  text-transform: uppercase;
  font-size: 10px;
  letter-spacing: 0.5px;
}
#planet-table td {
  padding: 4px 6px;
  border-bottom: 1px solid rgba(212, 207, 197, 0.5);
}
#planet-table .retrograde { color: #c0392b; font-size: 10px; margin-left: 2px; }
.aspect-filters {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 4px;
}
.aspect-filter {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #5a5348;
  cursor: pointer;
}
.aspect-filter input { margin: 0; accent-color: #8b7d6b; }
.aspect-filter .swatch {
  width: 16px;
  height: 3px;
  border-radius: 1px;
}
#main {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow: hidden;
}
#chart {
  max-width: 100%;
  max-height: 100%;
}
</style>
</head>
<body>
<div id="controls">
  <h2>Natal Chart Generator</h2>
  <div class="form-group">
    <label>Year</label>
    <div class="slider-row">
      <input type="range" id="birth-year" min="1925" max="2026" value="2000">
      <span class="slider-value" id="birth-year-val">2000</span>
    </div>
  </div>
  <div class="form-group">
    <label>Month</label>
    <div class="slider-row">
      <input type="range" id="birth-month" min="1" max="12" value="1">
      <span class="slider-value" id="birth-month-val">Jan</span>
    </div>
  </div>
  <div class="form-group">
    <label>Day</label>
    <div class="slider-row">
      <input type="range" id="birth-day" min="1" max="31" value="1">
      <span class="slider-value" id="birth-day-val">1</span>
    </div>
  </div>
  <div class="form-group">
    <label>Time of Birth</label>
    <div class="time-row">
      <select id="birth-hour"></select>
      <select id="birth-minute"></select>
    </div>
  </div>
  <div class="form-group">
    <label>Birth Location</label>
    <input type="text" id="location" value="Lexington, Fayette County" autocomplete="off">
    <div id="location-dropdown" class="dropdown"></div>
    <div id="location-info" class="location-display">38.0464°, -84.4970°</div>
  </div>
  <div id="error"></div>
  <div class="form-group">
    <label>Aspects</label>
    <div class="aspect-filters" id="aspect-filters"></div>
  </div>
  <div id="results">
    <h3>Planet Positions</h3>
    <table id="planet-table">
      <thead><tr><th>Planet</th><th>Sign</th><th>Degree</th></tr></thead>
      <tbody id="planet-tbody"></tbody>
    </table>
  </div>
</div>
<div id="main">
  <canvas id="chart" width="700" height="700"></canvas>
</div>

<script type="module">
import { Horoscope, Origin } from './horoscope-bundle.js';

// ── Constants ──────────────────────────────────────────────

const SIGNS = [
  { key: 'aries',       glyph: '\u2648', abbr: 'Ari', element: 'fire' },
  { key: 'taurus',      glyph: '\u2649', abbr: 'Tau', element: 'earth' },
  { key: 'gemini',      glyph: '\u264A', abbr: 'Gem', element: 'air' },
  { key: 'cancer',      glyph: '\u264B', abbr: 'Can', element: 'water' },
  { key: 'leo',         glyph: '\u264C', abbr: 'Leo', element: 'fire' },
  { key: 'virgo',       glyph: '\u264D', abbr: 'Vir', element: 'earth' },
  { key: 'libra',       glyph: '\u264E', abbr: 'Lib', element: 'air' },
  { key: 'scorpio',     glyph: '\u264F', abbr: 'Sco', element: 'water' },
  { key: 'sagittarius', glyph: '\u2650', abbr: 'Sag', element: 'fire' },
  { key: 'capricorn',   glyph: '\u2651', abbr: 'Cap', element: 'earth' },
  { key: 'aquarius',    glyph: '\u2652', abbr: 'Aqu', element: 'air' },
  { key: 'pisces',      glyph: '\u2653', abbr: 'Pis', element: 'water' },
];

const PLANET_KEYS = [
  'sun', 'moon', 'mercury', 'venus', 'mars',
  'jupiter', 'saturn', 'uranus', 'neptune', 'pluto',
];

const PLANET_GLYPHS = {
  sun: '\u2609', moon: '\u263D', mercury: '\u263F', venus: '\u2640',
  mars: '\u2642', jupiter: '\u2643', saturn: '\u2644', uranus: '\u2645',
  neptune: '\u2646', pluto: '\u2647', chiron: '\u26B7', northnode: '\u260A',
  sirius: '\u2605', southnode: '\u260B', lilith: '\u26B8',
};

const PLANET_NAMES = {
  sun: 'Sun', moon: 'Moon', mercury: 'Mercury', venus: 'Venus',
  mars: 'Mars', jupiter: 'Jupiter', saturn: 'Saturn', uranus: 'Uranus',
  neptune: 'Neptune', pluto: 'Pluto',
};

const ASPECT_STYLES = {
  conjunction: { color: '#6a9e6a', width: 1.2, dash: [] },
  sextile:     { color: '#6a8cad', width: 0.8, dash: [4, 4] },
  square:      { color: '#b85450', width: 1.2, dash: [] },
  trine:       { color: '#6a8cad', width: 1.2, dash: [] },
  opposition:  { color: '#b85450', width: 1.5, dash: [] },
};

// ── Aspect Filter Checkboxes ────────────────────────────────

const enabledAspects = new Set(Object.keys(ASPECT_STYLES));

{
  const container = document.getElementById('aspect-filters');
  for (const [key, style] of Object.entries(ASPECT_STYLES)) {
    const label = document.createElement('label');
    label.className = 'aspect-filter';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = true;
    cb.dataset.aspect = key;
    cb.addEventListener('change', () => {
      if (cb.checked) enabledAspects.add(key);
      else enabledAspects.delete(key);
      if (displayState) drawChartState(displayState);
    });
    const swatch = document.createElement('span');
    swatch.className = 'swatch';
    swatch.style.background = style.color;
    const name = key.charAt(0).toUpperCase() + key.slice(1);
    label.append(cb, swatch, document.createTextNode(name));
    container.appendChild(label);
  }
}

// ── Canvas Setup ───────────────────────────────────────────

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
const SIZE = 700;
canvas.width = SIZE * dpr;
canvas.height = SIZE * dpr;
canvas.style.width = SIZE + 'px';
canvas.style.height = SIZE + 'px';
ctx.scale(dpr, dpr);

const CX = SIZE / 2;
const CY = SIZE / 2;
const OUTER_R = 310;
const ZODIAC_INNER_R = 265;
const ASPECT_R = 265;
const PLANET_R = (OUTER_R + ASPECT_R) / 2;
const PLANET_INNER_R = 205;
const INNER_R = 145;

// ── State ──────────────────────────────────────────────────

let selectedLat = 38.0464;
let selectedLon = -84.4970;

// Animation state
let displayState = null;   // what's currently rendered
let fromState = null;      // animation start snapshot
let targetState = null;    // animation target
let animStartTime = null;
let animFrameId = null;
const ANIM_DURATION = 700; // ms

// Stage 2: spread + aspect fade state
let spreadT = 1;              // 0 = exact positions, 1 = fully spread
let spreadAnimId = null;
let spreadAnimStart = null;
const SPREAD_DURATION = 350;  // ms

let aspectAlpha = 1;
let aspectFadeId = null;
let aspectFadeStart = null;
const ASPECT_FADE_DURATION = 400; // ms

// Hover state
let hoveredAspect = null;    // { point1Key, point2Key, aspectKey, tooltipX, tooltipY } or null
let drawnAspects = [];       // cached for hit-testing
const HOVER_THRESHOLD = 6;   // px distance to detect hover

function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.hypot(px - x1, py - y1);
  let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
}

canvas.addEventListener('mousemove', (e) => {
  if (aspectAlpha < 1 || !drawnAspects.length) {
    if (hoveredAspect) { hoveredAspect = null; canvas.style.cursor = ''; drawChartState(displayState); }
    return;
  }
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (SIZE / rect.width);
  const my = (e.clientY - rect.top) * (SIZE / rect.height);

  let closest = null, closestDist = Infinity;
  for (const a of drawnAspects) {
    const d = distToSegment(mx, my, a.x1, a.y1, a.x2, a.y2);
    if (d < closestDist) { closestDist = d; closest = a; }
  }

  const prev = hoveredAspect;
  if (closest && closestDist < HOVER_THRESHOLD) {
    hoveredAspect = { ...closest, tooltipX: mx, tooltipY: my };
    canvas.style.cursor = 'pointer';
  } else {
    hoveredAspect = null;
    canvas.style.cursor = '';
  }

  const changed = (prev?.point1Key !== hoveredAspect?.point1Key ||
                   prev?.point2Key !== hoveredAspect?.point2Key);
  if (changed && displayState) drawChartState(displayState);
});

canvas.addEventListener('mouseleave', () => {
  if (hoveredAspect) {
    hoveredAspect = null;
    canvas.style.cursor = '';
    if (displayState) drawChartState(displayState);
  }
});

// ── Coordinate Helpers ─────────────────────────────────────

function eclToAngle(eclDeg, ascDeg) {
  return (180 - eclDeg + ascDeg) * Math.PI / 180;
}

function eclToXY(eclDeg, radius, ascDeg) {
  const a = eclToAngle(eclDeg, ascDeg);
  return { x: CX + radius * Math.cos(a), y: CY + radius * Math.sin(a) };
}

function normDeg(d) { return ((d % 360) + 360) % 360; }

function lerpAngle(from, to, t) {
  let diff = to - from;
  while (diff > 180) diff -= 360;
  while (diff < -180) diff += 360;
  return normDeg(from + diff * t);
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// ── Geocoding ──────────────────────────────────────────────

let searchTimeout = null;
const locationInput = document.getElementById('location');
const dropdown = document.getElementById('location-dropdown');
const locationInfo = document.getElementById('location-info');

locationInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const q = locationInput.value.trim();
  if (q.length < 2) { dropdown.classList.remove('open'); return; }
  searchTimeout = setTimeout(() => searchLocation(q), 300);
});

locationInput.addEventListener('blur', () => {
  setTimeout(() => dropdown.classList.remove('open'), 200);
});

async function searchLocation(query) {
  try {
    const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5`;
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    const data = await res.json();
    dropdown.innerHTML = '';
    if (!data.length) {
      dropdown.innerHTML = '<div class="dropdown-item" style="color:#8899aa">No results</div>';
      dropdown.classList.add('open');
      return;
    }
    for (const item of data) {
      const div = document.createElement('div');
      div.className = 'dropdown-item';
      div.textContent = item.display_name;
      div.addEventListener('mousedown', (e) => {
        e.preventDefault();
        selectedLat = parseFloat(item.lat);
        selectedLon = parseFloat(item.lon);
        const name = item.display_name.split(',').slice(0, 2).join(',');
        locationInput.value = name;
        locationInfo.textContent = `${selectedLat.toFixed(4)}°, ${selectedLon.toFixed(4)}°`;
        dropdown.classList.remove('open');
        generateChart();
      });
      dropdown.appendChild(div);
    }
    dropdown.classList.add('open');
  } catch (err) {
    console.error('Geocoding error:', err);
  }
}

// ── Chart State Extraction ─────────────────────────────────

function extractState(h) {
  const ascDeg = getAscendantDeg(h);
  const mcDeg = getMidheavenDeg(h);
  const planets = getBodyPositions(h);
  const cusps = getHouseCusps(h);
  return { ascDeg, mcDeg, planets, cusps, horoscope: h };
}

function lerpState(from, to, t) {
  return {
    ascDeg: lerpAngle(from.ascDeg, to.ascDeg, t),
    mcDeg: (from.mcDeg != null && to.mcDeg != null)
      ? lerpAngle(from.mcDeg, to.mcDeg, t) : to.mcDeg,
    planets: to.planets.map(tp => {
      const fp = from.planets.find(p => p.key === tp.key);
      if (!fp) return tp;
      return { ...tp, deg: lerpAngle(fp.deg, tp.deg, t) };
    }),
    cusps: to.cusps.map((tc, i) => {
      const fc = from.cusps[i];
      if (!fc) return tc;
      return { ...tc, deg: lerpAngle(fc.deg, tc.deg, t) };
    }),
    horoscope: to.horoscope,
  };
}

// ── Chart Generation & Animation ───────────────────────────

const errorEl = document.getElementById('error');
const resultsEl = document.getElementById('results');

function showError(msg) {
  errorEl.textContent = msg;
  errorEl.style.display = 'block';
  setTimeout(() => { errorEl.style.display = 'none'; }, 5000);
}

function generateChart() {
  errorEl.style.display = 'none';
  if (selectedLat === null) return;

  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const date = parseInt(document.getElementById('birth-day').value);
  const hour = parseInt(document.getElementById('birth-hour').value);
  const minute = parseInt(document.getElementById('birth-minute').value);

  let horoscope;
  try {
    const origin = new Origin({
      year, month: month - 1, date, hour, minute,
      latitude: selectedLat, longitude: selectedLon,
    });
    horoscope = new Horoscope({
      origin,
      houseSystem: 'placidus',
      zodiac: 'tropical',
      aspectPoints: ['all'],
      aspectTypes: ['major'],
      language: 'en',
    });
  } catch (err) {
    console.error('Horoscope error:', err);
    return showError('Error calculating chart. Check inputs.');
  }

  const newState = extractState(horoscope);
  animateTo(newState);
}

function animateTo(newState) {
  // Cancel any in-progress stage 2 animations
  if (spreadAnimId) { cancelAnimationFrame(spreadAnimId); spreadAnimId = null; }
  if (aspectFadeId) { cancelAnimationFrame(aspectFadeId); aspectFadeId = null; }
  spreadT = 0;
  aspectAlpha = 0;

  // First render — skip stage 1, go straight to stage 2
  if (!displayState) {
    displayState = newState;
    drawChartState(displayState);
    populateTable(newState.horoscope);
    resultsEl.style.display = 'block';
    startStage2();
    return;
  }

  // Cancel in-progress position animation
  if (animFrameId) cancelAnimationFrame(animFrameId);

  // Stage 1: animate positions (no spread)
  fromState = { ...displayState };
  targetState = newState;
  animStartTime = null;
  animFrameId = requestAnimationFrame(animStep);
}

function animStep(timestamp) {
  if (!animStartTime) animStartTime = timestamp;
  const elapsed = timestamp - animStartTime;
  const t = Math.min(elapsed / ANIM_DURATION, 1);
  const eased = easeInOutCubic(t);

  displayState = lerpState(fromState, targetState, eased);
  displayState.horoscope = targetState.horoscope;
  drawChartState(displayState);

  if (t < 1) {
    animFrameId = requestAnimationFrame(animStep);
  } else {
    displayState = targetState;
    fromState = null;
    targetState = null;
    animFrameId = null;
    populateTable(displayState.horoscope);
    resultsEl.style.display = 'block';
    startStage2();
  }
}

// ── Stage 2: Spread then Aspect Fade ────────────────────────

function startStage2() {
  spreadT = 0;
  spreadAnimStart = null;
  spreadAnimId = requestAnimationFrame(spreadStep);
}

function spreadStep(timestamp) {
  if (!spreadAnimStart) spreadAnimStart = timestamp;
  const elapsed = timestamp - spreadAnimStart;
  spreadT = Math.min(elapsed / SPREAD_DURATION, 1);
  spreadT = easeInOutCubic(spreadT);
  drawChartState(displayState);
  if (spreadT < 1) {
    spreadAnimId = requestAnimationFrame(spreadStep);
  } else {
    spreadAnimId = null;
    startAspectFade();
  }
}

function startAspectFade() {
  if (aspectFadeId) cancelAnimationFrame(aspectFadeId);
  aspectAlpha = 0;
  aspectFadeStart = null;
  aspectFadeId = requestAnimationFrame(aspectFadeStep);
}

function aspectFadeStep(timestamp) {
  if (!aspectFadeStart) aspectFadeStart = timestamp;
  const elapsed = timestamp - aspectFadeStart;
  aspectAlpha = Math.min(elapsed / ASPECT_FADE_DURATION, 1);
  drawChartState(displayState);
  if (aspectAlpha < 1) {
    aspectFadeId = requestAnimationFrame(aspectFadeStep);
  } else {
    aspectFadeId = null;
  }
}

// ── Input Setup & Listeners ─────────────────────────────────

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function daysInMonth(year, month) {
  return new Date(year, month, 0).getDate();
}

function updateDayMax() {
  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const max = daysInMonth(year, month);
  const daySlider = document.getElementById('birth-day');
  daySlider.max = max;
  if (parseInt(daySlider.value) > max) daySlider.value = max;
  document.getElementById('birth-day-val').textContent = daySlider.value;
}

// Populate hour dropdown (12:00 AM – 11:00 PM)
{
  const hourSel = document.getElementById('birth-hour');
  for (let h = 0; h < 24; h++) {
    const opt = document.createElement('option');
    opt.value = h;
    const display = h === 0 ? '12 AM' : h < 12 ? h + ' AM' : h === 12 ? '12 PM' : (h - 12) + ' PM';
    opt.textContent = display;
    hourSel.appendChild(opt);
  }
  hourSel.value = '12';
}

// Populate minute dropdown (00–59)
{
  const minSel = document.getElementById('birth-minute');
  for (let m = 0; m < 60; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = String(m).padStart(2, '0');
    minSel.appendChild(opt);
  }
  minSel.value = '0';
}

document.getElementById('birth-year').addEventListener('input', () => {
  document.getElementById('birth-year-val').textContent = document.getElementById('birth-year').value;
  updateDayMax();
  generateChart();
});
document.getElementById('birth-month').addEventListener('input', () => {
  const v = parseInt(document.getElementById('birth-month').value);
  document.getElementById('birth-month-val').textContent = MONTH_ABBR[v - 1];
  updateDayMax();
  generateChart();
});
document.getElementById('birth-day').addEventListener('input', () => {
  document.getElementById('birth-day-val').textContent = document.getElementById('birth-day').value;
  generateChart();
});
document.getElementById('birth-hour').addEventListener('change', generateChart);
document.getElementById('birth-minute').addEventListener('change', generateChart);

// ── Drawing from State ─────────────────────────────────────

function drawChartState(state) {
  const { ascDeg, mcDeg, planets, cusps } = state;
  ctx.clearRect(0, 0, SIZE, SIZE);

  // Fill band between outer ring and inner circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2, true);
  ctx.fillStyle = '#f5f0e6';
  ctx.fill();

  // Inner aspect circle
  ctx.beginPath();
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#b8b0a2';
  ctx.lineWidth = 0.8;
  ctx.stroke();

  drawZodiacRing(ascDeg);

  const degMap = {};
  for (const p of planets) degMap[p.key] = p.deg;
  drawAspectLines(state.horoscope, degMap, ascDeg);
  drawPlanets(planets, ascDeg);
}

function getAscendantDeg(h) {
  try { return h.Ascendant.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { try { return h.Houses[0].ChartPosition.StartPosition.Ecliptic.DecimalDegrees; }
  catch { return 0; } }
}

function getMidheavenDeg(h) {
  try { return h.Midheaven.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { return null; }
}

// ── Zodiac Ring ────────────────────────────────────────────

function drawZodiacRing(ascDeg) {
  // Zodiac circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#a89f92';
  ctx.lineWidth = 1.2;
  ctx.stroke();

  for (let i = 0; i < 12; i++) {
    const sign = SIGNS[i];
    const startEcl = i * 30;

    // Segment divider line spanning the band
    const p1 = eclToXY(startEcl, OUTER_R, ascDeg);
    const p2 = eclToXY(startEcl, ASPECT_R, ascDeg);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = '#a89f92';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Sign abbreviation on the outside
    const midEcl = startEcl + 15;
    const glyphPos = eclToXY(midEcl, OUTER_R + 16, ascDeg);
    ctx.font = '10px system-ui, sans-serif';
    ctx.fillStyle = '#8a8078';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(sign.abbr, glyphPos.x, glyphPos.y);
  }
}

// ── Houses ─────────────────────────────────────────────────

function getHouseCusps(h) {
  const cusps = [];
  try {
    for (let i = 0; i < h.Houses.length; i++) {
      const house = h.Houses[i];
      let deg;
      if (house.ChartPosition && house.ChartPosition.StartPosition) {
        deg = house.ChartPosition.StartPosition.Ecliptic.DecimalDegrees;
      } else if (house.ChartPosition && house.ChartPosition.Ecliptic) {
        deg = house.ChartPosition.Ecliptic.DecimalDegrees;
      }
      cusps.push({ id: house.id || (i + 1), deg: normDeg(deg) });
    }
  } catch (err) { console.error('Error reading house cusps:', err); }
  return cusps;
}

// ── Planets ────────────────────────────────────────────────

function getBodyPositions(h) {
  const positions = [];
  const addBody = (body, key) => {
    if (!body || !body.ChartPosition) return;
    const ecl = body.ChartPosition.Ecliptic;
    if (!ecl) return;
    positions.push({
      key,
      deg: normDeg(ecl.DecimalDegrees),
      sign: body.Sign ? body.Sign.key : null,
      signLabel: body.Sign ? body.Sign.label : '',
      house: body.House ? (body.House.id || '') : '',
      retrograde: !!body.isRetrograde,
      arcDeg: ecl.ArcDegrees || null,
      formatted30: ecl.ArcDegreesFormatted30 || '',
    });
  };
  for (const key of PLANET_KEYS) {
    const body = h.CelestialBodies[key] || (h.CelestialPoints && h.CelestialPoints[key]);
    addBody(body, key);
  }
  return positions;
}

function spreadPositions(positions, minGap) {
  // Build items: planets (movable) + sign boundaries (fixed)
  const items = positions.map(p => ({ ...p, displayDeg: p.deg, fixed: false }));
  for (let i = 0; i < 12; i++) {
    items.push({ deg: normDeg(i * 30), displayDeg: normDeg(i * 30), fixed: true, key: '_sign_' + i });
  }

  const n = items.length;
  items.sort((a, b) => a.deg - b.deg);

  // Linearize the circle by breaking at the largest gap
  let maxGap = -1, breakAfter = n - 1;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    const gap = normDeg(items[j].deg - items[i].deg);
    if (gap > maxGap) { maxGap = gap; breakAfter = i; }
  }
  const order = [];
  for (let i = 0; i < n; i++) order.push((breakAfter + 1 + i) % n);

  const baseDeg = items[order[0]].deg;
  const truePos = order.map(idx => {
    let d = items[idx].deg - baseDeg;
    if (d < 0) d += 360;
    return d;
  });
  const isFixed = order.map(idx => items[idx].fixed);

  // Layout a group: fixed items stay put, movable items fill around them
  function layoutGroup(g) {
    if (g.count === 1) return [g.truePositions[0]];
    if (!g.fixedFlags.some(f => f)) {
      // All movable: center on mean
      const mean = g.truePositions.reduce((a, b) => a + b) / g.count;
      const start = mean - (g.count - 1) * minGap / 2;
      return g.truePositions.map((_, i) => start + i * minGap);
    }
    // Mixed: two-pass sweep
    const d = g.truePositions.slice();
    // Left-to-right: push movable items right if too close
    for (let i = 1; i < g.count; i++) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    // Right-to-left: pull movable items back toward true position
    for (let i = g.count - 2; i >= 0; i--) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.min(d[i], d[i + 1] - minGap);
        if (i > 0) d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    return d;
  }

  // Iterative group merging
  let groups = truePos.map((p, i) => ({
    count: 1, truePositions: [p], fixedFlags: [isFixed[i]],
  }));

  let changed = true;
  while (changed) {
    changed = false;
    const merged = [groups[0]];
    for (let i = 1; i < groups.length; i++) {
      const prev = merged[merged.length - 1];
      const curr = groups[i];
      const prevLayout = layoutGroup(prev);
      const currLayout = layoutGroup(curr);
      if (currLayout[0] - prevLayout[prevLayout.length - 1] < minGap) {
        prev.truePositions = prev.truePositions.concat(curr.truePositions);
        prev.fixedFlags = prev.fixedFlags.concat(curr.fixedFlags);
        prev.count += curr.count;
        changed = true;
      } else {
        merged.push(curr);
      }
    }
    groups = merged;
  }

  // Assign display positions
  let itemIdx = 0;
  for (const g of groups) {
    const layout = layoutGroup(g);
    for (let i = 0; i < g.count; i++) {
      items[order[itemIdx]].displayDeg = normDeg(layout[i] + baseDeg);
      itemIdx++;
    }
  }

  return items.filter(p => !p.fixed);
}

function drawPlanets(bodyPositions, ascDeg) {
  const spread = spreadPositions(bodyPositions, 5);

  for (const p of spread) {
    // Interpolate between exact and spread position
    const renderDeg = lerpAngle(p.deg, p.displayDeg, spreadT);

    // Tick mark on inner aspect circle
    const tick1 = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
    const tick2 = eclToXY(p.deg, ASPECT_R - 4, ascDeg);
    ctx.beginPath();
    ctx.moveTo(tick1.x, tick1.y);
    ctx.lineTo(tick2.x, tick2.y);
    ctx.strokeStyle = '#8b8078';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Leader line if spread shifted the glyph
    const offset = Math.abs(normDeg(renderDeg - p.deg));
    if (offset > 1) {
      const from = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
      const to = eclToXY(renderDeg, PLANET_R, ascDeg);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = `rgba(139,128,120,${0.3 * spreadT})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Planet glyph
    const glyphP = eclToXY(renderDeg, PLANET_R, ascDeg);
    ctx.font = '22px system-ui, sans-serif';
    ctx.fillStyle = '#2c2c2c';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(PLANET_GLYPHS[p.key] || p.key[0].toUpperCase(), glyphP.x, glyphP.y);
  }
}

function formatDeg(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30.split("'")[0] + "'";
  if (p.arcDeg) return p.arcDeg.degrees + '°' + p.arcDeg.minutes + "'";
  const inSign = p.deg % 30;
  return Math.floor(inSign) + '°';
}

// ── Aspects ────────────────────────────────────────────────

function drawAspectLines(h, degMap, ascDeg) {
  drawnAspects = [];
  if (aspectAlpha <= 0) return;

  let aspects = [];
  try {
    if (h && h.Aspects && h.Aspects.all) aspects = h.Aspects.all;
    else if (Array.isArray(h?.Aspects)) aspects = h.Aspects;
  } catch { return; }

  for (const asp of aspects) {
    const key = asp.aspectKey || asp.key || '';
    if (!enabledAspects.has(key)) continue;
    const style = ASPECT_STYLES[key];
    if (!style) continue;

    const d1 = degMap[asp.point1Key];
    const d2 = degMap[asp.point2Key];
    if (d1 === undefined || d2 === undefined) continue;

    const p1 = eclToXY(d1, ASPECT_R, ascDeg);
    const p2 = eclToXY(d2, ASPECT_R, ascDeg);

    const isHovered = hoveredAspect &&
      hoveredAspect.point1Key === asp.point1Key &&
      hoveredAspect.point2Key === asp.point2Key;

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = style.color;
    ctx.lineWidth = isHovered ? style.width + 2.5 : style.width;
    ctx.setLineDash(style.dash);
    ctx.globalAlpha = isHovered ? 0.95 * aspectAlpha : 0.6 * aspectAlpha;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.setLineDash([]);

    drawnAspects.push({
      x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
      point1Key: asp.point1Key, point2Key: asp.point2Key,
      aspectKey: key,
    });
  }

  // Draw tooltip for hovered aspect
  if (hoveredAspect && aspectAlpha >= 1) {
    const ha = hoveredAspect;
    const name1 = PLANET_NAMES[ha.point1Key] || ha.point1Key;
    const name2 = PLANET_NAMES[ha.point2Key] || ha.point2Key;
    const label = `Your ${name1} and ${name2} are in ${ha.aspectKey}`;

    ctx.font = '12px system-ui, sans-serif';
    const metrics = ctx.measureText(label);
    const tw = metrics.width + 16;
    const th = 26;
    const tx = ha.tooltipX - tw / 2;
    const ty = ha.tooltipY - th - 10;

    ctx.fillStyle = 'rgba(58,54,48,0.9)';
    ctx.beginPath();
    ctx.roundRect(tx, ty, tw, th, 4);
    ctx.fill();

    ctx.fillStyle = '#f5f0e6';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, ha.tooltipX, ty + th / 2);
  }
}

// ── Angles (AC, MC) ───────────────────────────────────────

function drawAngles(ascDeg, mcDeg) {
  // AC
  const acP = eclToXY(ascDeg, OUTER_R + 5, ascDeg);
  const acI = eclToXY(ascDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(acP.x, acP.y); ctx.lineTo(acI.x, acI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const acL = eclToXY(ascDeg, OUTER_R + 18, ascDeg);
  ctx.font = 'bold 11px system-ui, sans-serif';
  ctx.fillStyle = '#3a3630'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('AC', acL.x, acL.y);

  // DC
  const dcDeg = normDeg(ascDeg + 180);
  const dcP = eclToXY(dcDeg, OUTER_R + 5, ascDeg);
  const dcI = eclToXY(dcDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(dcP.x, dcP.y); ctx.lineTo(dcI.x, dcI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const dcL = eclToXY(dcDeg, OUTER_R + 18, ascDeg);
  ctx.fillStyle = '#3a3630';
  ctx.fillText('DC', dcL.x, dcL.y);

  // MC
  if (mcDeg != null) {
    const mcP = eclToXY(mcDeg, OUTER_R + 5, ascDeg);
    const mcI = eclToXY(mcDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(mcP.x, mcP.y); ctx.lineTo(mcI.x, mcI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const mcL = eclToXY(mcDeg, OUTER_R + 18, ascDeg);
    ctx.font = 'bold 11px system-ui, sans-serif';
    ctx.fillStyle = '#5a524a';
    ctx.fillText('MC', mcL.x, mcL.y);

    // IC
    const icDeg = normDeg(mcDeg + 180);
    const icP = eclToXY(icDeg, OUTER_R + 5, ascDeg);
    const icI = eclToXY(icDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(icP.x, icP.y); ctx.lineTo(icI.x, icI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const icL = eclToXY(icDeg, OUTER_R + 18, ascDeg);
    ctx.fillText('IC', icL.x, icL.y);
  }
}

// ── Results Table ──────────────────────────────────────────

function populateTable(h) {
  const tbody = document.getElementById('planet-tbody');
  tbody.innerHTML = '';
  const positions = getBodyPositions(h);

  for (const p of positions) {
    const sign = SIGNS.find(s => s.key === p.sign) || SIGNS.find(s => p.sign && s.key.startsWith(p.sign.toLowerCase()));
    const signName = p.signLabel || (sign ? sign.abbr : '');
    const degStr = formatDegFull(p);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${PLANET_NAMES[p.key] || p.key}</td>
      <td>${signName}</td>
      <td>${degStr}</td>`;
    tbody.appendChild(tr);
  }

}

function formatDegFull(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30;
  if (p.arcDeg) return p.arcDeg.degrees + '° ' + p.arcDeg.minutes + "' " + (p.arcDeg.seconds || 0) + "''";
  const inSign = p.deg % 30;
  const d = Math.floor(inSign);
  const m = Math.floor((inSign - d) * 60);
  return d + '° ' + m + "'";
}

// ── Boot ───────────────────────────────────────────────────

generateChart();

</script>
</body>
</html>
