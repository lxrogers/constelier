<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Natal Chart Generator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: system-ui, sans-serif;
  background-color: #f5f0e6;
  background-image:
    linear-gradient(rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(rgba(180,172,158,0.10) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(180,172,158,0.10) 0.5px, transparent 0.5px);
  background-size:
    100px 100px,
    100px 100px,
    20px 20px,
    20px 20px;
  color: #2c2c2c;
  display: flex;
  height: 100vh;
  overflow: hidden;
}
#controls {
  width: 320px;
  min-width: 320px;
  background: rgba(237,232,222,0.85);
  border-right: 1px solid #d4cfc5;
  padding: 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
#controls h2 {
  font-size: 16px;
  color: #3a3630;
  margin-bottom: 4px;
}
.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  position: relative;
}
.form-group label {
  font-size: 12px;
  color: #7a7568;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
input[type="text"] {
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 8px 10px;
  border-radius: 4px;
  font-size: 14px;
  font-family: system-ui, sans-serif;
  outline: none;
}
input[type="text"]:focus { border-color: #8b7d6b; }
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: #d4cfc5;
  border-radius: 2px;
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border-radius: 50%;
  cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border: none;
  border-radius: 50%;
  cursor: pointer;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.slider-row input[type="range"] { flex: 1; }
.slider-value {
  font-size: 13px;
  color: #3a3630;
  min-width: 36px;
  text-align: right;
  font-variant-numeric: tabular-nums;
}
.time-row {
  display: flex;
  gap: 8px;
}
.time-row select {
  flex: 1;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 13px;
  font-family: system-ui, sans-serif;
  outline: none;
}
.time-row select:focus { border-color: #8b7d6b; }
.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  border-top: none;
  border-radius: 0 0 4px 4px;
  z-index: 100;
  display: none;
  max-height: 200px;
  overflow-y: auto;
}
.dropdown.open { display: block; }
.dropdown-item {
  padding: 8px 10px;
  font-size: 13px;
  cursor: pointer;
  border-bottom: 1px solid #ede8de;
}
.dropdown-item:hover { background: #ede8de; }
.location-display {
  font-size: 11px;
  color: #7a7568;
  margin-top: 2px;
}
#error {
  color: #c0392b;
  font-size: 13px;
  display: none;
}
#results {
  display: none;
  flex: 1;
  overflow-y: auto;
}
#results h3 {
  font-size: 13px;
  color: #3a3630;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#planet-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
#planet-table th {
  text-align: left;
  padding: 4px 6px;
  border-bottom: 1px solid #d4cfc5;
  color: #7a7568;
  font-weight: normal;
  text-transform: uppercase;
  font-size: 10px;
  letter-spacing: 0.5px;
}
#planet-table td {
  padding: 4px 6px;
  border-bottom: 1px solid rgba(212, 207, 197, 0.5);
}
#planet-table .retrograde { color: #c0392b; font-size: 10px; margin-left: 2px; }
.aspect-filters {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 4px;
}
.aspect-filter {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #5a5348;
  cursor: pointer;
}
.aspect-filter input { margin: 0; accent-color: #8b7d6b; }
.aspect-filter .swatch {
  width: 16px;
  height: 3px;
  border-radius: 1px;
}
#main {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow: hidden;
}
#chart {
  max-width: 100%;
  max-height: 100%;
}
</style>
</head>
<body>
<div id="controls">
  <h2>Natal Chart Generator</h2>
  <div class="form-group">
    <label>Year</label>
    <div class="slider-row">
      <input type="range" id="birth-year" min="1925" max="2026" value="2000">
      <span class="slider-value" id="birth-year-val">2000</span>
    </div>
  </div>
  <div class="form-group">
    <label>Month</label>
    <div class="slider-row">
      <input type="range" id="birth-month" min="1" max="12" value="1">
      <span class="slider-value" id="birth-month-val">Jan</span>
    </div>
  </div>
  <div class="form-group">
    <label>Day</label>
    <div class="slider-row">
      <input type="range" id="birth-day" min="1" max="31" value="1">
      <span class="slider-value" id="birth-day-val">1</span>
    </div>
  </div>
  <div class="form-group">
    <label>Time of Birth</label>
    <div class="time-row">
      <select id="birth-hour"></select>
      <select id="birth-minute"></select>
    </div>
  </div>
  <div class="form-group">
    <label>Birth Location</label>
    <input type="text" id="location" value="Lexington, Fayette County" autocomplete="off">
    <div id="location-dropdown" class="dropdown"></div>
    <div id="location-info" class="location-display">38.0464°, -84.4970°</div>
  </div>
  <div id="error"></div>
  <div class="form-group">
    <label>Aspects</label>
    <div class="aspect-filters" id="aspect-filters"></div>
  </div>
  <div class="form-group">
    <label>Chart Opacity</label>
    <div class="slider-row">
      <input type="range" id="chart-opacity" min="0" max="100" value="40">
      <span class="slider-value" id="chart-opacity-val">40%</span>
    </div>
  </div>
  <div class="form-group">
    <label>Fillet Radius</label>
    <div class="slider-row">
      <input type="range" id="fillet-radius" min="0" max="20" step="0.5" value="5">
      <span class="slider-value" id="fillet-radius-val">5</span>
    </div>
  </div>
</div>
<div id="main">
  <canvas id="chart" width="700" height="700"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/makerjs@0/target/js/browser.maker.js"></script>
<script>window.makerjs = require('makerjs');</script>
<script type="module">
import { Horoscope, Origin } from './horoscope-bundle.js';
const m = window.makerjs;

// ── Constants ──────────────────────────────────────────────

const SIGNS = [
  { key: 'aries',       glyph: '\u2648', abbr: 'Ari', element: 'fire' },
  { key: 'taurus',      glyph: '\u2649', abbr: 'Tau', element: 'earth' },
  { key: 'gemini',      glyph: '\u264A', abbr: 'Gem', element: 'air' },
  { key: 'cancer',      glyph: '\u264B', abbr: 'Can', element: 'water' },
  { key: 'leo',         glyph: '\u264C', abbr: 'Leo', element: 'fire' },
  { key: 'virgo',       glyph: '\u264D', abbr: 'Vir', element: 'earth' },
  { key: 'libra',       glyph: '\u264E', abbr: 'Lib', element: 'air' },
  { key: 'scorpio',     glyph: '\u264F', abbr: 'Sco', element: 'water' },
  { key: 'sagittarius', glyph: '\u2650', abbr: 'Sag', element: 'fire' },
  { key: 'capricorn',   glyph: '\u2651', abbr: 'Cap', element: 'earth' },
  { key: 'aquarius',    glyph: '\u2652', abbr: 'Aqu', element: 'air' },
  { key: 'pisces',      glyph: '\u2653', abbr: 'Pis', element: 'water' },
];

const PLANET_KEYS = [
  'sun', 'moon', 'mercury', 'venus', 'mars',
  'jupiter', 'saturn', 'uranus', 'neptune', 'pluto',
];

const PLANET_GLYPHS = {
  sun: '\u2609', moon: '\u263D', mercury: '\u263F', venus: '\u2640',
  mars: '\u2642', jupiter: '\u2643', saturn: '\u2644', uranus: '\u2645',
  neptune: '\u2646', pluto: '\u2647', chiron: '\u26B7', northnode: '\u260A',
  sirius: '\u2605', southnode: '\u260B', lilith: '\u26B8',
};

const PLANET_NAMES = {
  sun: 'Sun', moon: 'Moon', mercury: 'Mercury', venus: 'Venus',
  mars: 'Mars', jupiter: 'Jupiter', saturn: 'Saturn', uranus: 'Uranus',
  neptune: 'Neptune', pluto: 'Pluto',
};

const ASPECT_STYLES = {
  conjunction: { color: '#6a9e6a', width: 1.2, dash: [] },
  sextile:     { color: '#6a8cad', width: 0.8, dash: [4, 4] },
  square:      { color: '#b85450', width: 1.2, dash: [] },
  trine:       { color: '#6a8cad', width: 1.2, dash: [] },
  opposition:  { color: '#b85450', width: 1.5, dash: [] },
};

// ── Aspect Filter Checkboxes ────────────────────────────────

const enabledAspects = new Set(Object.keys(ASPECT_STYLES));

{
  const container = document.getElementById('aspect-filters');
  for (const [key, style] of Object.entries(ASPECT_STYLES)) {
    const label = document.createElement('label');
    label.className = 'aspect-filter';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = true;
    cb.dataset.aspect = key;
    cb.addEventListener('change', () => {
      if (cb.checked) enabledAspects.add(key);
      else enabledAspects.delete(key);
      if (displayState) drawChartState(displayState);
    });
    const swatch = document.createElement('span');
    swatch.className = 'swatch';
    swatch.style.background = style.color;
    const name = key.charAt(0).toUpperCase() + key.slice(1);
    label.append(cb, swatch, document.createTextNode(name));
    container.appendChild(label);
  }
}

// ── Canvas Setup ───────────────────────────────────────────

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
const SIZE = 700;
canvas.width = SIZE * dpr;
canvas.height = SIZE * dpr;
canvas.style.width = SIZE + 'px';
canvas.style.height = SIZE + 'px';
ctx.scale(dpr, dpr);

const CX = SIZE / 2;
const CY = SIZE / 2;
const OUTER_R = 310;
const ZODIAC_INNER_R = 265;
const ASPECT_R = 265;
const PLANET_R = (OUTER_R + ASPECT_R) / 2;
const PLANET_INNER_R = 205;
const INNER_R = 145;
const PENDANT_R = 100 * (ASPECT_R - 10) / 105; // canvas radius matching pendant's inner circle

// ── State ──────────────────────────────────────────────────

let selectedLat = 38.0464;
let selectedLon = -84.4970;
let chartOpacity = 0.4;
let filletRadius = 5;

// Animation state
let displayState = null;   // what's currently rendered
let fromState = null;      // animation start snapshot
let targetState = null;    // animation target
let animStartTime = null;
let animFrameId = null;
const ANIM_DURATION = 700; // ms

// Stage 2: spread + aspect fade state
let spreadT = 1;              // 0 = exact positions, 1 = fully spread
let spreadAnimId = null;
let spreadAnimStart = null;
const SPREAD_DURATION = 350;  // ms

let aspectAlpha = 1;
let aspectFadeId = null;
let aspectFadeStart = null;
const ASPECT_FADE_DURATION = 400; // ms

// Hover state
let hoveredAspect = null;    // { point1Key, point2Key, aspectKey, tooltipX, tooltipY } or null
let drawnAspects = [];       // cached for hit-testing
const HOVER_THRESHOLD = 6;   // px distance to detect hover

function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.hypot(px - x1, py - y1);
  let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
}

canvas.addEventListener('mousemove', (e) => {
  if (aspectAlpha < 1 || !drawnAspects.length) {
    if (hoveredAspect) { hoveredAspect = null; canvas.style.cursor = ''; drawChartState(displayState); }
    return;
  }
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (SIZE / rect.width);
  const my = (e.clientY - rect.top) * (SIZE / rect.height);

  let closest = null, closestDist = Infinity;
  for (const a of drawnAspects) {
    const d = distToSegment(mx, my, a.x1, a.y1, a.x2, a.y2);
    if (d < closestDist) { closestDist = d; closest = a; }
  }

  const prev = hoveredAspect;
  if (closest && closestDist < HOVER_THRESHOLD) {
    hoveredAspect = { ...closest, tooltipX: mx, tooltipY: my };
    canvas.style.cursor = 'pointer';
  } else {
    hoveredAspect = null;
    canvas.style.cursor = '';
  }

  const changed = (prev?.point1Key !== hoveredAspect?.point1Key ||
                   prev?.point2Key !== hoveredAspect?.point2Key);
  if (changed && displayState) drawChartState(displayState);
});

canvas.addEventListener('mouseleave', () => {
  if (hoveredAspect) {
    hoveredAspect = null;
    canvas.style.cursor = '';
    if (displayState) drawChartState(displayState);
  }
});

// ── Coordinate Helpers ─────────────────────────────────────

function eclToAngle(eclDeg, ascDeg) {
  return (180 - eclDeg + ascDeg) * Math.PI / 180;
}

function eclToXY(eclDeg, radius, ascDeg) {
  const a = eclToAngle(eclDeg, ascDeg);
  return { x: CX + radius * Math.cos(a), y: CY + radius * Math.sin(a) };
}

function normDeg(d) { return ((d % 360) + 360) % 360; }

function lerpAngle(from, to, t) {
  let diff = to - from;
  while (diff > 180) diff -= 360;
  while (diff < -180) diff += 360;
  return normDeg(from + diff * t);
}

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

// ── Geocoding ──────────────────────────────────────────────

let searchTimeout = null;
const locationInput = document.getElementById('location');
const dropdown = document.getElementById('location-dropdown');
const locationInfo = document.getElementById('location-info');

locationInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const q = locationInput.value.trim();
  if (q.length < 2) { dropdown.classList.remove('open'); return; }
  searchTimeout = setTimeout(() => searchLocation(q), 300);
});

locationInput.addEventListener('blur', () => {
  setTimeout(() => dropdown.classList.remove('open'), 200);
});

async function searchLocation(query) {
  try {
    const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5`;
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    const data = await res.json();
    dropdown.innerHTML = '';
    if (!data.length) {
      dropdown.innerHTML = '<div class="dropdown-item" style="color:#8899aa">No results</div>';
      dropdown.classList.add('open');
      return;
    }
    for (const item of data) {
      const div = document.createElement('div');
      div.className = 'dropdown-item';
      div.textContent = item.display_name;
      div.addEventListener('mousedown', (e) => {
        e.preventDefault();
        selectedLat = parseFloat(item.lat);
        selectedLon = parseFloat(item.lon);
        const name = item.display_name.split(',').slice(0, 2).join(',');
        locationInput.value = name;
        locationInfo.textContent = `${selectedLat.toFixed(4)}°, ${selectedLon.toFixed(4)}°`;
        dropdown.classList.remove('open');
        generateChart();
      });
      dropdown.appendChild(div);
    }
    dropdown.classList.add('open');
  } catch (err) {
    console.error('Geocoding error:', err);
  }
}

// ── Chart State Extraction ─────────────────────────────────

function extractState(h) {
  const ascDeg = getAscendantDeg(h);
  const mcDeg = getMidheavenDeg(h);
  const planets = getBodyPositions(h);
  const cusps = getHouseCusps(h);
  return { ascDeg, mcDeg, planets, cusps, horoscope: h };
}

function lerpState(from, to, t) {
  return {
    ascDeg: lerpAngle(from.ascDeg, to.ascDeg, t),
    mcDeg: (from.mcDeg != null && to.mcDeg != null)
      ? lerpAngle(from.mcDeg, to.mcDeg, t) : to.mcDeg,
    planets: to.planets.map(tp => {
      const fp = from.planets.find(p => p.key === tp.key);
      if (!fp) return tp;
      return { ...tp, deg: lerpAngle(fp.deg, tp.deg, t) };
    }),
    cusps: to.cusps.map((tc, i) => {
      const fc = from.cusps[i];
      if (!fc) return tc;
      return { ...tc, deg: lerpAngle(fc.deg, tc.deg, t) };
    }),
    horoscope: to.horoscope,
  };
}

// ── Chart Generation & Animation ───────────────────────────

const errorEl = document.getElementById('error');

function showError(msg) {
  errorEl.textContent = msg;
  errorEl.style.display = 'block';
  setTimeout(() => { errorEl.style.display = 'none'; }, 5000);
}

function generateChart() {
  errorEl.style.display = 'none';
  if (selectedLat === null) return;

  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const date = parseInt(document.getElementById('birth-day').value);
  const hour = parseInt(document.getElementById('birth-hour').value);
  const minute = parseInt(document.getElementById('birth-minute').value);

  let horoscope;
  try {
    const origin = new Origin({
      year, month: month - 1, date, hour, minute,
      latitude: selectedLat, longitude: selectedLon,
    });
    horoscope = new Horoscope({
      origin,
      houseSystem: 'placidus',
      zodiac: 'tropical',
      aspectPoints: ['all'],
      aspectTypes: ['major'],
      language: 'en',
    });
  } catch (err) {
    console.error('Horoscope error:', err);
    return showError('Error calculating chart. Check inputs.');
  }

  const newState = extractState(horoscope);
  animateTo(newState);
}

function animateTo(newState) {
  // Cancel any in-progress stage 2 animations
  if (spreadAnimId) { cancelAnimationFrame(spreadAnimId); spreadAnimId = null; }
  if (aspectFadeId) { cancelAnimationFrame(aspectFadeId); aspectFadeId = null; }
  if (pendantFadeId) { cancelAnimationFrame(pendantFadeId); pendantFadeId = null; }
  spreadT = 0;
  aspectAlpha = 0;
  pendantAlpha = 0;
  pendantModelData = null;

  // First render — skip stage 1, go straight to stage 2
  if (!displayState) {
    displayState = newState;
    drawChartState(displayState);
    startStage2();
    return;
  }

  // Cancel in-progress position animation
  if (animFrameId) cancelAnimationFrame(animFrameId);

  // Stage 1: animate positions (no spread)
  fromState = { ...displayState };
  targetState = newState;
  animStartTime = null;
  animFrameId = requestAnimationFrame(animStep);
}

function animStep(timestamp) {
  if (!animStartTime) animStartTime = timestamp;
  const elapsed = timestamp - animStartTime;
  const t = Math.min(elapsed / ANIM_DURATION, 1);
  const eased = easeInOutCubic(t);

  displayState = lerpState(fromState, targetState, eased);
  displayState.horoscope = targetState.horoscope;
  drawChartState(displayState);

  if (t < 1) {
    animFrameId = requestAnimationFrame(animStep);
  } else {
    displayState = targetState;
    fromState = null;
    targetState = null;
    animFrameId = null;
    startStage2();
  }
}

// ── Stage 2: Spread then Aspect Fade ────────────────────────

function startStage2() {
  spreadT = 0;
  spreadAnimStart = null;
  spreadAnimId = requestAnimationFrame(spreadStep);
}

function spreadStep(timestamp) {
  if (!spreadAnimStart) spreadAnimStart = timestamp;
  const elapsed = timestamp - spreadAnimStart;
  spreadT = Math.min(elapsed / SPREAD_DURATION, 1);
  spreadT = easeInOutCubic(spreadT);
  drawChartState(displayState);
  if (spreadT < 1) {
    spreadAnimId = requestAnimationFrame(spreadStep);
  } else {
    spreadAnimId = null;
    startAspectFade();
  }
}

function startAspectFade() {
  if (aspectFadeId) cancelAnimationFrame(aspectFadeId);
  aspectAlpha = 0;
  aspectFadeStart = null;
  aspectFadeId = requestAnimationFrame(aspectFadeStep);
}

function aspectFadeStep(timestamp) {
  if (!aspectFadeStart) aspectFadeStart = timestamp;
  const elapsed = timestamp - aspectFadeStart;
  aspectAlpha = Math.min(elapsed / ASPECT_FADE_DURATION, 1);
  drawChartState(displayState);
  if (aspectAlpha < 1) {
    aspectFadeId = requestAnimationFrame(aspectFadeStep);
  } else {
    aspectFadeId = null;
    renderPendantOnCanvas();
  }
}

// ── Input Setup & Listeners ─────────────────────────────────

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function daysInMonth(year, month) {
  return new Date(year, month, 0).getDate();
}

function updateDayMax() {
  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const max = daysInMonth(year, month);
  const daySlider = document.getElementById('birth-day');
  daySlider.max = max;
  if (parseInt(daySlider.value) > max) daySlider.value = max;
  document.getElementById('birth-day-val').textContent = daySlider.value;
}

// Populate hour dropdown (12:00 AM – 11:00 PM)
{
  const hourSel = document.getElementById('birth-hour');
  for (let h = 0; h < 24; h++) {
    const opt = document.createElement('option');
    opt.value = h;
    const display = h === 0 ? '12 AM' : h < 12 ? h + ' AM' : h === 12 ? '12 PM' : (h - 12) + ' PM';
    opt.textContent = display;
    hourSel.appendChild(opt);
  }
  hourSel.value = '12';
}

// Populate minute dropdown (00–59)
{
  const minSel = document.getElementById('birth-minute');
  for (let m = 0; m < 60; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = String(m).padStart(2, '0');
    minSel.appendChild(opt);
  }
  minSel.value = '0';
}

document.getElementById('birth-year').addEventListener('input', () => {
  document.getElementById('birth-year-val').textContent = document.getElementById('birth-year').value;
  updateDayMax();
  generateChart();
});
document.getElementById('birth-month').addEventListener('input', () => {
  const v = parseInt(document.getElementById('birth-month').value);
  document.getElementById('birth-month-val').textContent = MONTH_ABBR[v - 1];
  updateDayMax();
  generateChart();
});
document.getElementById('birth-day').addEventListener('input', () => {
  document.getElementById('birth-day-val').textContent = document.getElementById('birth-day').value;
  generateChart();
});
document.getElementById('birth-hour').addEventListener('change', generateChart);
document.getElementById('birth-minute').addEventListener('change', generateChart);
document.getElementById('chart-opacity').addEventListener('input', () => {
  const v = parseInt(document.getElementById('chart-opacity').value);
  document.getElementById('chart-opacity-val').textContent = v + '%';
  chartOpacity = v / 100;
  if (displayState) drawChartState(displayState);
});
document.getElementById('fillet-radius').addEventListener('input', () => {
  const v = parseFloat(document.getElementById('fillet-radius').value);
  document.getElementById('fillet-radius-val').textContent = v;
  filletRadius = v;
  if (displayState) {
    pendantModelData = buildPendantFromChart(displayState.horoscope, displayState.ascDeg);
    pendantAlpha = 1;
    drawChartState(displayState);
  }
});

// ── Drawing from State ─────────────────────────────────────

function drawChartState(state) {
  const { ascDeg, mcDeg, planets, cusps } = state;
  ctx.clearRect(0, 0, SIZE, SIZE);

  drawPendant();

  // Chart elements drawn with chartOpacity
  ctx.globalAlpha = chartOpacity;

  // Fill band between outer ring and inner circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2, true);
  ctx.fillStyle = '#f5f0e6';
  ctx.fill();

  // Inner aspect circle
  ctx.beginPath();
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#b8b0a2';
  ctx.lineWidth = 0.8;
  ctx.stroke();

  drawZodiacRing(ascDeg);

  const degMap = {};
  for (const p of planets) degMap[p.key] = p.deg;
  drawAspectLines(state.horoscope, degMap, ascDeg);
  drawPlanets(planets, ascDeg);

  ctx.globalAlpha = 1;
}

function getAscendantDeg(h) {
  try { return h.Ascendant.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { try { return h.Houses[0].ChartPosition.StartPosition.Ecliptic.DecimalDegrees; }
  catch { return 0; } }
}

function getMidheavenDeg(h) {
  try { return h.Midheaven.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { return null; }
}

// ── Zodiac Ring ────────────────────────────────────────────

function drawZodiacRing(ascDeg) {
  // Zodiac circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#a89f92';
  ctx.lineWidth = 1.2;
  ctx.stroke();

  for (let i = 0; i < 12; i++) {
    const sign = SIGNS[i];
    const startEcl = i * 30;

    // Segment divider line spanning the band
    const p1 = eclToXY(startEcl, OUTER_R, ascDeg);
    const p2 = eclToXY(startEcl, ASPECT_R, ascDeg);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = '#a89f92';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Sign abbreviation on the outside
    const midEcl = startEcl + 15;
    const glyphPos = eclToXY(midEcl, OUTER_R + 16, ascDeg);
    ctx.font = '10px system-ui, sans-serif';
    ctx.fillStyle = '#8a8078';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(sign.abbr, glyphPos.x, glyphPos.y);
  }
}

// ── Houses ─────────────────────────────────────────────────

function getHouseCusps(h) {
  const cusps = [];
  try {
    for (let i = 0; i < h.Houses.length; i++) {
      const house = h.Houses[i];
      let deg;
      if (house.ChartPosition && house.ChartPosition.StartPosition) {
        deg = house.ChartPosition.StartPosition.Ecliptic.DecimalDegrees;
      } else if (house.ChartPosition && house.ChartPosition.Ecliptic) {
        deg = house.ChartPosition.Ecliptic.DecimalDegrees;
      }
      cusps.push({ id: house.id || (i + 1), deg: normDeg(deg) });
    }
  } catch (err) { console.error('Error reading house cusps:', err); }
  return cusps;
}

// ── Planets ────────────────────────────────────────────────

function getBodyPositions(h) {
  const positions = [];
  const addBody = (body, key) => {
    if (!body || !body.ChartPosition) return;
    const ecl = body.ChartPosition.Ecliptic;
    if (!ecl) return;
    positions.push({
      key,
      deg: normDeg(ecl.DecimalDegrees),
      sign: body.Sign ? body.Sign.key : null,
      signLabel: body.Sign ? body.Sign.label : '',
      house: body.House ? (body.House.id || '') : '',
      retrograde: !!body.isRetrograde,
      arcDeg: ecl.ArcDegrees || null,
      formatted30: ecl.ArcDegreesFormatted30 || '',
    });
  };
  for (const key of PLANET_KEYS) {
    const body = h.CelestialBodies[key] || (h.CelestialPoints && h.CelestialPoints[key]);
    addBody(body, key);
  }
  return positions;
}

function spreadPositions(positions, minGap) {
  // Build items: planets (movable) + sign boundaries (fixed)
  const items = positions.map(p => ({ ...p, displayDeg: p.deg, fixed: false }));
  for (let i = 0; i < 12; i++) {
    items.push({ deg: normDeg(i * 30), displayDeg: normDeg(i * 30), fixed: true, key: '_sign_' + i });
  }

  const n = items.length;
  items.sort((a, b) => a.deg - b.deg);

  // Linearize the circle by breaking at the largest gap
  let maxGap = -1, breakAfter = n - 1;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    const gap = normDeg(items[j].deg - items[i].deg);
    if (gap > maxGap) { maxGap = gap; breakAfter = i; }
  }
  const order = [];
  for (let i = 0; i < n; i++) order.push((breakAfter + 1 + i) % n);

  const baseDeg = items[order[0]].deg;
  const truePos = order.map(idx => {
    let d = items[idx].deg - baseDeg;
    if (d < 0) d += 360;
    return d;
  });
  const isFixed = order.map(idx => items[idx].fixed);

  // Layout a group: fixed items stay put, movable items fill around them
  function layoutGroup(g) {
    if (g.count === 1) return [g.truePositions[0]];
    if (!g.fixedFlags.some(f => f)) {
      // All movable: center on mean
      const mean = g.truePositions.reduce((a, b) => a + b) / g.count;
      const start = mean - (g.count - 1) * minGap / 2;
      return g.truePositions.map((_, i) => start + i * minGap);
    }
    // Mixed: two-pass sweep
    const d = g.truePositions.slice();
    // Left-to-right: push movable items right if too close
    for (let i = 1; i < g.count; i++) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    // Right-to-left: pull movable items back toward true position
    for (let i = g.count - 2; i >= 0; i--) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.min(d[i], d[i + 1] - minGap);
        if (i > 0) d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    return d;
  }

  // Iterative group merging
  let groups = truePos.map((p, i) => ({
    count: 1, truePositions: [p], fixedFlags: [isFixed[i]],
  }));

  let changed = true;
  while (changed) {
    changed = false;
    const merged = [groups[0]];
    for (let i = 1; i < groups.length; i++) {
      const prev = merged[merged.length - 1];
      const curr = groups[i];
      const prevLayout = layoutGroup(prev);
      const currLayout = layoutGroup(curr);
      if (currLayout[0] - prevLayout[prevLayout.length - 1] < minGap) {
        prev.truePositions = prev.truePositions.concat(curr.truePositions);
        prev.fixedFlags = prev.fixedFlags.concat(curr.fixedFlags);
        prev.count += curr.count;
        changed = true;
      } else {
        merged.push(curr);
      }
    }
    groups = merged;
  }

  // Assign display positions
  let itemIdx = 0;
  for (const g of groups) {
    const layout = layoutGroup(g);
    for (let i = 0; i < g.count; i++) {
      items[order[itemIdx]].displayDeg = normDeg(layout[i] + baseDeg);
      itemIdx++;
    }
  }

  return items.filter(p => !p.fixed);
}

function drawPlanets(bodyPositions, ascDeg) {
  const spread = spreadPositions(bodyPositions, 5);

  for (const p of spread) {
    // Interpolate between exact and spread position
    const renderDeg = lerpAngle(p.deg, p.displayDeg, spreadT);

    // Tick mark on inner aspect circle
    const tick1 = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
    const tick2 = eclToXY(p.deg, ASPECT_R - 4, ascDeg);
    ctx.beginPath();
    ctx.moveTo(tick1.x, tick1.y);
    ctx.lineTo(tick2.x, tick2.y);
    ctx.strokeStyle = '#8b8078';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Leader line if spread shifted the glyph
    const offset = Math.abs(normDeg(renderDeg - p.deg));
    if (offset > 1) {
      const from = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
      const to = eclToXY(renderDeg, PLANET_R, ascDeg);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = `rgba(139,128,120,${0.3 * spreadT})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Planet glyph
    const glyphP = eclToXY(renderDeg, PLANET_R, ascDeg);
    ctx.font = '22px system-ui, sans-serif';
    ctx.fillStyle = '#2c2c2c';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(PLANET_GLYPHS[p.key] || p.key[0].toUpperCase(), glyphP.x, glyphP.y);
  }
}

function formatDeg(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30.split("'")[0] + "'";
  if (p.arcDeg) return p.arcDeg.degrees + '°' + p.arcDeg.minutes + "'";
  const inSign = p.deg % 30;
  return Math.floor(inSign) + '°';
}

// ── Aspects ────────────────────────────────────────────────

function drawAspectLines(h, degMap, ascDeg) {
  drawnAspects = [];
  if (aspectAlpha <= 0) return;

  let aspects = [];
  try {
    if (h && h.Aspects && h.Aspects.all) aspects = h.Aspects.all;
    else if (Array.isArray(h?.Aspects)) aspects = h.Aspects;
  } catch { return; }

  for (const asp of aspects) {
    const key = asp.aspectKey || asp.key || '';
    if (!enabledAspects.has(key)) continue;
    const style = ASPECT_STYLES[key];
    if (!style) continue;

    const d1 = degMap[asp.point1Key];
    const d2 = degMap[asp.point2Key];
    if (d1 === undefined || d2 === undefined) continue;

    const p1 = eclToXY(d1, PENDANT_R, ascDeg);
    const p2 = eclToXY(d2, PENDANT_R, ascDeg);

    const isHovered = hoveredAspect &&
      hoveredAspect.point1Key === asp.point1Key &&
      hoveredAspect.point2Key === asp.point2Key;

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = style.color;
    ctx.lineWidth = isHovered ? style.width + 2.5 : style.width;
    ctx.setLineDash(style.dash);
    ctx.globalAlpha = isHovered ? 0.95 * aspectAlpha : 0.6 * aspectAlpha;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.setLineDash([]);

    drawnAspects.push({
      x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
      point1Key: asp.point1Key, point2Key: asp.point2Key,
      aspectKey: key,
    });
  }

  // Draw tooltip for hovered aspect
  if (hoveredAspect && aspectAlpha >= 1) {
    const ha = hoveredAspect;
    const name1 = PLANET_NAMES[ha.point1Key] || ha.point1Key;
    const name2 = PLANET_NAMES[ha.point2Key] || ha.point2Key;
    const label = `Your ${name1} and ${name2} are in ${ha.aspectKey}`;

    ctx.font = '12px system-ui, sans-serif';
    const metrics = ctx.measureText(label);
    const tw = metrics.width + 16;
    const th = 26;
    const tx = ha.tooltipX - tw / 2;
    const ty = ha.tooltipY - th - 10;

    ctx.fillStyle = 'rgba(58,54,48,0.9)';
    ctx.beginPath();
    ctx.roundRect(tx, ty, tw, th, 4);
    ctx.fill();

    ctx.fillStyle = '#f5f0e6';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, ha.tooltipX, ty + th / 2);
  }
}

// ── Angles (AC, MC) ───────────────────────────────────────

function drawAngles(ascDeg, mcDeg) {
  // AC
  const acP = eclToXY(ascDeg, OUTER_R + 5, ascDeg);
  const acI = eclToXY(ascDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(acP.x, acP.y); ctx.lineTo(acI.x, acI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const acL = eclToXY(ascDeg, OUTER_R + 18, ascDeg);
  ctx.font = 'bold 11px system-ui, sans-serif';
  ctx.fillStyle = '#3a3630'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('AC', acL.x, acL.y);

  // DC
  const dcDeg = normDeg(ascDeg + 180);
  const dcP = eclToXY(dcDeg, OUTER_R + 5, ascDeg);
  const dcI = eclToXY(dcDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(dcP.x, dcP.y); ctx.lineTo(dcI.x, dcI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const dcL = eclToXY(dcDeg, OUTER_R + 18, ascDeg);
  ctx.fillStyle = '#3a3630';
  ctx.fillText('DC', dcL.x, dcL.y);

  // MC
  if (mcDeg != null) {
    const mcP = eclToXY(mcDeg, OUTER_R + 5, ascDeg);
    const mcI = eclToXY(mcDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(mcP.x, mcP.y); ctx.lineTo(mcI.x, mcI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const mcL = eclToXY(mcDeg, OUTER_R + 18, ascDeg);
    ctx.font = 'bold 11px system-ui, sans-serif';
    ctx.fillStyle = '#5a524a';
    ctx.fillText('MC', mcL.x, mcL.y);

    // IC
    const icDeg = normDeg(mcDeg + 180);
    const icP = eclToXY(icDeg, OUTER_R + 5, ascDeg);
    const icI = eclToXY(icDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(icP.x, icP.y); ctx.lineTo(icI.x, icI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const icL = eclToXY(icDeg, OUTER_R + 18, ascDeg);
    ctx.fillText('IC', icL.x, icL.y);
  }
}

// ── Results Table ──────────────────────────────────────────

function populateTable(h) {
  const tbody = document.getElementById('planet-tbody');
  tbody.innerHTML = '';
  const positions = getBodyPositions(h);

  for (const p of positions) {
    const sign = SIGNS.find(s => s.key === p.sign) || SIGNS.find(s => p.sign && s.key.startsWith(p.sign.toLowerCase()));
    const signName = p.signLabel || (sign ? sign.abbr : '');
    const degStr = formatDegFull(p);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${PLANET_NAMES[p.key] || p.key}</td>
      <td>${signName}</td>
      <td>${degStr}</td>`;
    tbody.appendChild(tr);
  }

}

function formatDegFull(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30;
  if (p.arcDeg) return p.arcDeg.degrees + '° ' + p.arcDeg.minutes + "' " + (p.arcDeg.seconds || 0) + "''";
  const inSign = p.deg % 30;
  const d = Math.floor(inSign);
  const m = Math.floor((inSign - d) * 60);
  return d + '° ' + m + "'";
}

// ── MakerJS Pendant Build ──────────────────────────────────

let pendantModelData = null; // cached MakerJS model for drawing on canvas
let pendantAlpha = 0;
let pendantFadeId = null;
let pendantFadeStart = null;
const PENDANT_FADE_DURATION = 500;

function computeChords(planetAngles, aspectAngles, orb) {
  const lines = [];
  for (let i = 0; i < planetAngles.length; i++) {
    for (let j = i + 1; j < planetAngles.length; j++) {
      let diff = Math.abs(planetAngles[i] - planetAngles[j]);
      if (diff > 180) diff = 360 - diff;
      for (const asp of aspectAngles) {
        if (Math.abs(diff - asp) <= orb) {
          lines.push({
            a1: planetAngles[i] * Math.PI / 180,
            a2: planetAngles[j] * Math.PI / 180,
          });
          break;
        }
      }
    }
  }
  return lines;
}

function polygonArea(pts) {
  var n = pts.length;
  if (n < 3) return 0;
  var area = 0;
  for (var i = 0; i < n; i++) {
    var j = (i + 1) % n;
    area += pts[i][0] * pts[j][1] - pts[j][0] * pts[i][1];
  }
  return Math.abs(area) / 2;
}

function cornerAngle(linkA, linkB) {
  var pcA = linkA.walkedPath.pathContext;
  var pcB = linkB.walkedPath.pathContext;
  var dax, day;
  if (pcA.type === 'line') {
    dax = pcA.end[0] - pcA.origin[0]; day = pcA.end[1] - pcA.origin[1];
    if (linkA.reversed) { dax = -dax; day = -day; }
  } else if (pcA.type === 'arc') {
    var a = (linkA.reversed ? pcA.startAngle : pcA.endAngle) * Math.PI / 180;
    if (linkA.reversed) { dax = Math.sin(a); day = -Math.cos(a); }
    else { dax = -Math.sin(a); day = Math.cos(a); }
  } else return 90;
  var dbx, dby;
  if (pcB.type === 'line') {
    dbx = pcB.end[0] - pcB.origin[0]; dby = pcB.end[1] - pcB.origin[1];
    if (linkB.reversed) { dbx = -dbx; dby = -dby; }
  } else if (pcB.type === 'arc') {
    var a = (linkB.reversed ? pcB.endAngle : pcB.startAngle) * Math.PI / 180;
    if (linkB.reversed) { dbx = Math.sin(a); dby = -Math.cos(a); }
    else { dbx = -Math.sin(a); dby = Math.cos(a); }
  } else return 90;
  var lenA = Math.hypot(dax, day), lenB = Math.hypot(dbx, dby);
  if (lenA < 1e-10 || lenB < 1e-10) return 90;
  var dot = Math.max(-1, Math.min(1, (dax * dbx + day * dby) / (lenA * lenB)));
  return 180 - Math.acos(dot) * 180 / Math.PI;
}

function chainMinAngle(chain) {
  var links = chain.links;
  if (!links || links.length < 2) return 180;
  var minAng = 180;
  var count = chain.endless ? links.length : links.length - 1;
  for (var i = 0; i < count; i++) {
    var k = (i + 1) % links.length;
    var interior = cornerAngle(links[i], links[k]);
    if (interior < minAng) minAng = interior;
  }
  return minAng;
}

function manualLineFillet(linkA, linkB, radius) {
  var pcA = linkA.walkedPath.pathContext;
  var pcB = linkB.walkedPath.pathContext;
  if (pcA.type !== 'line' || pcB.type !== 'line') return null;

  var endA = linkA.reversed ? pcA.origin : pcA.end;
  var startB = linkB.reversed ? pcB.end : pcB.origin;
  var px = (endA[0] + startB[0]) / 2, py = (endA[1] + startB[1]) / 2;

  var farA = linkA.reversed ? pcA.end : pcA.origin;
  var farB = linkB.reversed ? pcB.origin : pcB.end;

  var dax = px - farA[0], day = py - farA[1];
  var la = Math.hypot(dax, day);
  if (la < 1e-10) return null;
  dax /= la; day /= la;

  var dbx = farB[0] - px, dby = farB[1] - py;
  var lb = Math.hypot(dbx, dby);
  if (lb < 1e-10) return null;
  dbx /= lb; dby /= lb;

  var cross = dax * dby - day * dbx;
  if (Math.abs(cross) < 1e-10) return null;

  var side = cross < 0 ? -1 : 1;
  var nax = side * (-day), nay = side * dax;
  var nbx = side * (-dby), nby = side * dbx;

  var oax = px + radius * nax, oay = py + radius * nay;
  var obx = px + radius * nbx, oby = py + radius * nby;

  var det = dbx * day - dby * dax;
  if (Math.abs(det) < 1e-10) return null;
  var ddx = obx - oax, ddy = oby - oay;
  var s = (ddy * dax - ddx * day) / det;
  var cx = obx + s * dbx, cy = oby + s * dby;

  var tA = (cx - farA[0]) * dax + (cy - farA[1]) * day;
  var tpAx = farA[0] + tA * dax, tpAy = farA[1] + tA * day;

  var tB = (cx - px) * dbx + (cy - py) * dby;
  var tpBx = px + tB * dbx, tpBy = py + tB * dby;

  if (tA < 0 || tA > la) return null;
  if (tB < 0 || tB > lb) return null;

  var angA = Math.atan2(tpAy - cy, tpAx - cx) * 180 / Math.PI;
  var angB = Math.atan2(tpBy - cy, tpBx - cx) * 180 / Math.PI;
  if (angA < 0) angA += 360;
  if (angB < 0) angB += 360;

  var span = angB - angA;
  if (span < 0) span += 360;
  var startAng, endAng;
  if (span <= 180) { startAng = angA; endAng = angB; }
  else { startAng = angB; endAng = angA; }

  if (linkA.reversed) pcA.origin = [tpAx, tpAy];
  else pcA.end = [tpAx, tpAy];
  if (linkB.reversed) pcB.end = [tpBx, tpBy];
  else pcB.origin = [tpBx, tpBy];

  return { type: 'arc', origin: [cx, cy], radius: radius, startAngle: startAng, endAngle: endAng };
}

function applyFillet(result, fr) {
  if (fr <= 0) return;
  var fChains = m.model.findChains(result);
  var filletsModel = { paths: {} };
  var fi = 0;
  for (var i = 0; i < fChains.length; i++) {
    var chain = fChains[i];
    var links = chain.links;
    if (!links || links.length < 2) continue;
    var count = chain.endless ? links.length : links.length - 1;
    for (var j = 0; j < count; j++) {
      var k = (j + 1) % links.length;
      var pathA = links[j].walkedPath.pathContext;
      var pathB = links[k].walkedPath.pathContext;
      var interior = cornerAngle(links[j], links[k]);
      var span = Math.max(15, 180 - interior);
      var startR = fr * Math.pow(90 / span, 1.5);
      var arc = null;
      var tryR = startR;
      for (var attempt = 0; attempt < 12 && tryR >= 0.3; attempt++) {
        try { arc = m.path.fillet(pathA, pathB, tryR); } catch { arc = null; }
        if (arc) break;
        tryR *= 0.65;
      }
      if (!arc) {
        tryR = startR;
        for (var attempt = 0; attempt < 12 && tryR >= 0.3; attempt++) {
          arc = manualLineFillet(links[j], links[k], tryR);
          if (arc) break;
          tryR *= 0.65;
        }
      }
      if (arc) filletsModel.paths['f' + (fi++)] = arc;
    }
  }
  result.models.fillets = filletsModel;
}

function deepCloneModel(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (Array.isArray(obj)) return obj.map(deepCloneModel);
  var clone = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) clone[key] = deepCloneModel(obj[key]);
  }
  return clone;
}

function buildPendantModel(chords, expansion, circleRadius, borderThickness, minArea, minAngle, fr) {
  var lineModel = { paths: {} };
  for (var i = 0; i < chords.length; i++) {
    var c = chords[i];
    var x1 = Math.cos(c.a1) * circleRadius, y1 = Math.sin(c.a1) * circleRadius;
    var x2 = Math.cos(c.a2) * circleRadius, y2 = Math.sin(c.a2) * circleRadius;
    var dx = x2 - x1, dy = y2 - y1;
    var len = Math.hypot(dx, dy);
    if (len < 1e-10) continue;
    var ext = expansion * 3 / len;
    lineModel.paths['line' + i] = new m.paths.Line(
      [x1 - dx * ext, y1 - dy * ext],
      [x2 + dx * ext, y2 + dy * ext]
    );
  }

  var expanded = m.model.expandPaths(lineModel, expansion);
  var circle = { paths: { circle: new m.paths.Circle([0, 0], circleRadius) } };
  m.model.combine(expanded, circle, true, false, false, true);
  var result = { models: { expanded: expanded, circle: circle } };

  // Pre-pass: collapse short segments
  if (expansion > 0) {
    var threshold = expansion * 1.5;
    var preChains = m.model.findChains(result);
    var changed = true;
    while (changed) {
      changed = false;
      for (var i = 0; i < preChains.length; i++) {
        var chain = preChains[i];
        var links = chain.links;
        if (!links || links.length < 3) continue;
        for (var j = 0; j < links.length; j++) {
          var pc = links[j].walkedPath.pathContext;
          var segLen = 0;
          if (pc.type === 'arc') {
            var sp = pc.endAngle - pc.startAngle;
            if (sp < 0) sp += 360;
            if (sp > 360) sp -= 360;
            segLen = (sp / 360) * 2 * Math.PI * pc.radius;
          } else if (pc.type === 'line') {
            segLen = Math.hypot(pc.end[0] - pc.origin[0], pc.end[1] - pc.origin[1]);
          } else continue;
          if (segLen >= threshold) continue;

          var prevIdx = (j - 1 + links.length) % links.length;
          var nextIdx = (j + 1) % links.length;
          var prevPc = links[prevIdx].walkedPath.pathContext;
          var nextPc = links[nextIdx].walkedPath.pathContext;
          if (prevPc.type !== 'line' && nextPc.type !== 'line') continue;

          if (prevPc.type === 'line' && nextPc.type === 'line') {
            var ax1 = prevPc.origin[0], ay1 = prevPc.origin[1];
            var ax2 = prevPc.end[0], ay2 = prevPc.end[1];
            var cx1 = nextPc.origin[0], cy1 = nextPc.origin[1];
            var cx2 = nextPc.end[0], cy2 = nextPc.end[1];
            var dax = ax2 - ax1, day = ay2 - ay1;
            var dcx = cx2 - cx1, dcy = cy2 - cy1;
            var det = dax * dcy - day * dcx;
            var meet;
            if (Math.abs(det) < 1e-10) {
              if (pc.type === 'arc') {
                var sp2 = pc.endAngle - pc.startAngle;
                if (sp2 < 0) sp2 += 360;
                var midAngle = (pc.startAngle + sp2 / 2) * Math.PI / 180;
                meet = [pc.origin[0] + pc.radius * Math.cos(midAngle),
                        pc.origin[1] + pc.radius * Math.sin(midAngle)];
              } else {
                meet = [(pc.origin[0] + pc.end[0]) / 2, (pc.origin[1] + pc.end[1]) / 2];
              }
            } else {
              var t = ((cx1 - ax1) * dcy - (cy1 - ay1) * dcx) / det;
              meet = [ax1 + t * dax, ay1 + t * day];
            }
            if (links[prevIdx].reversed) prevPc.origin = meet;
            else prevPc.end = meet;
            if (links[nextIdx].reversed) nextPc.end = meet;
            else nextPc.origin = meet;
          } else if (prevPc.type === 'line' && nextPc.type === 'arc') {
            var lx1 = prevPc.origin[0], ly1 = prevPc.origin[1];
            var ldx = prevPc.end[0] - lx1, ldy = prevPc.end[1] - ly1;
            var ccx = nextPc.origin[0], ccy = nextPc.origin[1], cr = nextPc.radius;
            var exx = lx1 - ccx, eyy = ly1 - ccy;
            var qa = ldx * ldx + ldy * ldy;
            var qb = 2 * (exx * ldx + eyy * ldy);
            var qc = exx * exx + eyy * eyy - cr * cr;
            var disc = qb * qb - 4 * qa * qc;
            if (disc >= 0 && qa > 1e-10) {
              var sq = Math.sqrt(disc);
              var t1 = (-qb + sq) / (2 * qa), t2 = (-qb - sq) / (2 * qa);
              var p1 = [lx1 + t1 * ldx, ly1 + t1 * ldy];
              var p2 = [lx1 + t2 * ldx, ly1 + t2 * ldy];
              var rAng = (links[nextIdx].reversed ? nextPc.endAngle : nextPc.startAngle) * Math.PI / 180;
              var rPt = [ccx + cr * Math.cos(rAng), ccy + cr * Math.sin(rAng)];
              var d1 = (p1[0]-rPt[0])*(p1[0]-rPt[0]) + (p1[1]-rPt[1])*(p1[1]-rPt[1]);
              var d2 = (p2[0]-rPt[0])*(p2[0]-rPt[0]) + (p2[1]-rPt[1])*(p2[1]-rPt[1]);
              var meet = d1 < d2 ? p1 : p2;
              if (links[prevIdx].reversed) prevPc.origin = meet;
              else prevPc.end = meet;
              var nAng = Math.atan2(meet[1] - ccy, meet[0] - ccx) * 180 / Math.PI;
              if (nAng < 0) nAng += 360;
              if (links[nextIdx].reversed) nextPc.endAngle = nAng;
              else nextPc.startAngle = nAng;
            } else {
              var arcAng = (links[nextIdx].reversed ? nextPc.endAngle : nextPc.startAngle) * Math.PI / 180;
              var arcPt = [ccx + cr * Math.cos(arcAng), ccy + cr * Math.sin(arcAng)];
              if (links[prevIdx].reversed) prevPc.origin = arcPt;
              else prevPc.end = arcPt;
            }
          } else {
            var lx1 = nextPc.origin[0], ly1 = nextPc.origin[1];
            var ldx = nextPc.end[0] - lx1, ldy = nextPc.end[1] - ly1;
            var ccx = prevPc.origin[0], ccy = prevPc.origin[1], cr = prevPc.radius;
            var exx = lx1 - ccx, eyy = ly1 - ccy;
            var qa = ldx * ldx + ldy * ldy;
            var qb = 2 * (exx * ldx + eyy * ldy);
            var qc = exx * exx + eyy * eyy - cr * cr;
            var disc = qb * qb - 4 * qa * qc;
            if (disc >= 0 && qa > 1e-10) {
              var sq = Math.sqrt(disc);
              var t1 = (-qb + sq) / (2 * qa), t2 = (-qb - sq) / (2 * qa);
              var p1 = [lx1 + t1 * ldx, ly1 + t1 * ldy];
              var p2 = [lx1 + t2 * ldx, ly1 + t2 * ldy];
              var rAng = (links[prevIdx].reversed ? prevPc.startAngle : prevPc.endAngle) * Math.PI / 180;
              var rPt = [ccx + cr * Math.cos(rAng), ccy + cr * Math.sin(rAng)];
              var d1 = (p1[0]-rPt[0])*(p1[0]-rPt[0]) + (p1[1]-rPt[1])*(p1[1]-rPt[1]);
              var d2 = (p2[0]-rPt[0])*(p2[0]-rPt[0]) + (p2[1]-rPt[1])*(p2[1]-rPt[1]);
              var meet = d1 < d2 ? p1 : p2;
              if (links[nextIdx].reversed) nextPc.end = meet;
              else nextPc.origin = meet;
              var nAng = Math.atan2(meet[1] - ccy, meet[0] - ccx) * 180 / Math.PI;
              if (nAng < 0) nAng += 360;
              if (links[prevIdx].reversed) prevPc.startAngle = nAng;
              else prevPc.endAngle = nAng;
            } else {
              var arcAng = (links[prevIdx].reversed ? prevPc.startAngle : prevPc.endAngle) * Math.PI / 180;
              var arcPt = [ccx + cr * Math.cos(arcAng), ccy + cr * Math.sin(arcAng)];
              if (links[nextIdx].reversed) nextPc.end = arcPt;
              else nextPc.origin = arcPt;
            }
          }

          var wp = links[j].walkedPath;
          if (wp.modelContext && wp.modelContext.paths) {
            delete wp.modelContext.paths[wp.pathId];
          }
          changed = true;
          break;
        }
        if (changed) break;
      }
      if (changed) preChains = m.model.findChains(result);
    }
  }

  // Filter small closed regions (by area and min corner angle)
  if (minArea > 0 || minAngle > 0) {
    var chains = m.model.findChains(result);
    for (var i = 0; i < chains.length; i++) {
      var chain = chains[i];
      if (!chain.endless) continue;
      try {
        var pts = m.chain.toKeyPoints(chain, 1);
        var area = polygonArea(pts);
        var angle = chainMinAngle(chain);
        var tooSmall = minArea > 0 && area < minArea;
        var tooNarrow = minAngle > 0 && angle < minAngle;
        if (tooSmall || tooNarrow) {
          for (var j = 0; j < chain.links.length; j++) {
            var wp = chain.links[j].walkedPath;
            if (wp && wp.modelContext && wp.modelContext.paths) {
              delete wp.modelContext.paths[wp.pathId];
            }
          }
        }
      } catch {}
    }
  }

  // Border
  if (borderThickness > 0) {
    result.models.border = {
      paths: { outer: new m.paths.Circle([0, 0], circleRadius + borderThickness) }
    };
  }

  // Fillet
  if (fr > 0) applyFillet(result, fr);

  return result;
}

function buildPendantFromChart(horoscope, ascDeg) {
  // Build planet angle lookup (chart-rotated)
  const planetAngles = {};
  for (const key of PLANET_KEYS) {
    const body = horoscope.CelestialBodies[key] || (horoscope.CelestialPoints && horoscope.CelestialPoints[key]);
    if (body?.ChartPosition?.Ecliptic) {
      const ecl = body.ChartPosition.Ecliptic.DecimalDegrees;
      planetAngles[key] = normDeg(180 - ecl + ascDeg) * Math.PI / 180;
    }
  }

  // Use the exact same aspects the horoscope library computed
  let aspects = [];
  try {
    if (horoscope.Aspects?.all) aspects = horoscope.Aspects.all;
    else if (Array.isArray(horoscope.Aspects)) aspects = horoscope.Aspects;
  } catch {}

  const chords = [];
  for (const asp of aspects) {
    const key = asp.aspectKey || asp.key || '';
    if (!enabledAspects.has(key)) continue;
    const a1 = planetAngles[asp.point1Key];
    const a2 = planetAngles[asp.point2Key];
    if (a1 === undefined || a2 === undefined) continue;
    chords.push({ a1, a2 });
  }
  if (chords.length === 0) return null;

  const r = 100;
  const model = buildPendantModel(chords, 3, r, 5, 185, 5, filletRadius);
  return { model, r };
}

function renderPendantOnCanvas() {
  if (!displayState?.horoscope) return;
  try {
    pendantModelData = buildPendantFromChart(displayState.horoscope, displayState.ascDeg);
  } catch (err) {
    console.error('Pendant build error:', err);
    pendantModelData = null;
    return;
  }
  if (!pendantModelData) return;
  startPendantFade();
}

function startPendantFade() {
  if (pendantFadeId) cancelAnimationFrame(pendantFadeId);
  pendantAlpha = 0;
  pendantFadeStart = null;
  pendantFadeId = requestAnimationFrame(pendantFadeStep);
}

function pendantFadeStep(timestamp) {
  if (!pendantFadeStart) pendantFadeStart = timestamp;
  const elapsed = timestamp - pendantFadeStart;
  pendantAlpha = Math.min(elapsed / PENDANT_FADE_DURATION, 1);
  if (displayState) drawChartState(displayState);
  if (pendantAlpha < 1) {
    pendantFadeId = requestAnimationFrame(pendantFadeStep);
  } else {
    pendantFadeId = null;
  }
}

function drawPendant() {
  if (!pendantModelData || pendantAlpha <= 0) return;
  const { model, r } = pendantModelData;
  const b = 5; // borderThickness used in buildPendantModel
  const outerR = r + b;

  // Fit the model inside the inner circle
  const drawR = ASPECT_R - 10;
  const scale = drawR / outerR;

  ctx.save();
  ctx.beginPath();
  ctx.arc(CX, CY, ASPECT_R - 2, 0, Math.PI * 2);
  ctx.clip();
  ctx.globalAlpha = pendantAlpha;
  ctx.translate(CX, CY);
  ctx.scale(scale, scale);

  // Find cutout regions from chains
  const fillChains = m.model.findChains(model);
  const circleArea = Math.PI * r * r;
  const cutouts = [];
  for (const ch of fillChains) {
    if (!ch.endless) continue;
    try {
      const pts = m.chain.toKeyPoints(ch, 1);
      if (pts.length < 3) continue;
      const area = polygonArea(pts);
      if (area >= circleArea * 0.95) continue;
      cutouts.push(pts);
    } catch {}
  }

  // Fill pendant material with beige, cutouts left transparent (grid shows through)
  ctx.beginPath();
  ctx.arc(0, 0, outerR, 0, Math.PI * 2);
  for (const pts of cutouts) {
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j][0], pts[j][1]);
    ctx.closePath();
  }
  ctx.fillStyle = '#f5f0e6';
  ctx.fill('evenodd');

  // Stroke the outer border and cutout outlines
  ctx.strokeStyle = '#5a524a';
  ctx.lineWidth = 0.5 / scale;
  ctx.beginPath();
  ctx.arc(0, 0, outerR, 0, Math.PI * 2);
  ctx.stroke();
  for (const pts of cutouts) {
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j][0], pts[j][1]);
    ctx.closePath();
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

// ── Boot ───────────────────────────────────────────────────

generateChart();

</script>
</body>
</html>
