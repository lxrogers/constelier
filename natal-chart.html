<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Natal Chart Generator</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: system-ui, sans-serif;
  background-color: #f5f0e6;
  background-image:
    linear-gradient(rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(170,162,148,0.18) 0.5px, transparent 0.5px),
    linear-gradient(rgba(180,172,158,0.10) 0.5px, transparent 0.5px),
    linear-gradient(90deg, rgba(180,172,158,0.10) 0.5px, transparent 0.5px);
  background-size:
    100px 100px,
    100px 100px,
    20px 20px,
    20px 20px;
  color: #2c2c2c;
  display: flex;
  height: 100vh;
  overflow: hidden;
}
#controls {
  width: 320px;
  min-width: 320px;
  background: rgba(237,232,222,0.85);
  border-right: 1px solid #d4cfc5;
  padding: 20px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}
#controls h2 {
  font-size: 16px;
  color: #3a3630;
  margin-bottom: 4px;
}
.form-group {
  display: flex;
  flex-direction: column;
  gap: 4px;
  position: relative;
}
.form-group label {
  font-size: 12px;
  color: #7a7568;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
input[type="text"] {
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 8px 10px;
  border-radius: 4px;
  font-size: 14px;
  font-family: system-ui, sans-serif;
  outline: none;
}
input[type="text"]:focus { border-color: #8b7d6b; }
input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: #d4cfc5;
  border-radius: 2px;
  outline: none;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border-radius: 50%;
  cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
  width: 14px;
  height: 14px;
  background: #8b7d6b;
  border: none;
  border-radius: 50%;
  cursor: pointer;
}
.slider-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.slider-row input[type="range"] { flex: 1; }
.slider-value {
  font-size: 13px;
  color: #3a3630;
  min-width: 36px;
  text-align: right;
  font-variant-numeric: tabular-nums;
}
.time-row {
  display: flex;
  gap: 8px;
}
.time-row select {
  flex: 1;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  color: #2c2c2c;
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 13px;
  font-family: system-ui, sans-serif;
  outline: none;
}
.time-row select:focus { border-color: #8b7d6b; }
.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #faf7f0;
  border: 1px solid #d4cfc5;
  border-top: none;
  border-radius: 0 0 4px 4px;
  z-index: 100;
  display: none;
  max-height: 200px;
  overflow-y: auto;
}
.dropdown.open { display: block; }
.dropdown-item {
  padding: 8px 10px;
  font-size: 13px;
  cursor: pointer;
  border-bottom: 1px solid #ede8de;
}
.dropdown-item:hover { background: #ede8de; }
.location-display {
  font-size: 11px;
  color: #7a7568;
  margin-top: 2px;
}
#error {
  color: #c0392b;
  font-size: 13px;
  display: none;
}
#results {
  display: none;
  flex: 1;
  overflow-y: auto;
}
#results h3 {
  font-size: 13px;
  color: #3a3630;
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
#planet-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}
#planet-table th {
  text-align: left;
  padding: 4px 6px;
  border-bottom: 1px solid #d4cfc5;
  color: #7a7568;
  font-weight: normal;
  text-transform: uppercase;
  font-size: 10px;
  letter-spacing: 0.5px;
}
#planet-table td {
  padding: 4px 6px;
  border-bottom: 1px solid rgba(212, 207, 197, 0.5);
}
#planet-table .retrograde { color: #c0392b; font-size: 10px; margin-left: 2px; }
.aspect-filters {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-top: 4px;
}
.aspect-filter {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
  color: #5a5348;
  cursor: pointer;
}
.aspect-filter input { margin: 0; accent-color: #8b7d6b; }
.aspect-filter .swatch {
  width: 16px;
  height: 3px;
  border-radius: 1px;
}
#main {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  overflow: hidden;
  position: relative;
}
#chart-3d {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 700px;
  height: 700px;
  opacity: 0;
  transition: opacity 0.8s ease;
  pointer-events: none;
  clip-path: circle(310px at center);
}
#chart {
  max-width: 100%;
  max-height: 100%;
}
</style>
</head>
<body>
<div id="controls">
  <h2>Natal Chart Generator</h2>
  <div class="form-group">
    <label>Year</label>
    <div class="slider-row">
      <input type="range" id="birth-year" min="1925" max="2026" value="2000">
      <span class="slider-value" id="birth-year-val">2000</span>
    </div>
  </div>
  <div class="form-group">
    <label>Month</label>
    <div class="slider-row">
      <input type="range" id="birth-month" min="1" max="12" value="1">
      <span class="slider-value" id="birth-month-val">Jan</span>
    </div>
  </div>
  <div class="form-group">
    <label>Day</label>
    <div class="slider-row">
      <input type="range" id="birth-day" min="1" max="31" value="1">
      <span class="slider-value" id="birth-day-val">1</span>
    </div>
  </div>
  <div class="form-group">
    <label>Time of Birth</label>
    <div class="time-row">
      <select id="birth-hour"></select>
      <select id="birth-minute"></select>
    </div>
  </div>
  <div class="form-group">
    <label>Birth Location</label>
    <input type="text" id="location" value="Lexington, Fayette County" autocomplete="off">
    <div id="location-dropdown" class="dropdown"></div>
    <div id="location-info" class="location-display">38.0464°, -84.4970°</div>
  </div>
  <div id="error"></div>
  <div class="form-group">
    <label>Aspects</label>
    <div class="aspect-filters" id="aspect-filters"></div>
  </div>
  <div class="form-group">
    <label>Chart Opacity</label>
    <div class="slider-row">
      <input type="range" id="chart-opacity" min="0" max="100" value="40">
      <span class="slider-value" id="chart-opacity-val">40%</span>
    </div>
  </div>
  <div class="form-group">
    <label>Fillet Radius</label>
    <div class="slider-row">
      <input type="range" id="fillet-radius" min="0" max="20" step="0.5" value="5">
      <span class="slider-value" id="fillet-radius-val">5</span>
    </div>
  </div>
  <div class="form-group">
    <label>3D Scale</label>
    <div class="slider-row">
      <input type="range" id="scale-3d" min="50" max="150" step="1" value="100">
      <span class="slider-value" id="scale-3d-val">100%</span>
    </div>
  </div>
</div>
<div id="main">
  <canvas id="chart" width="700" height="700"></canvas>
  <canvas id="chart-3d" width="700" height="700"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/makerjs@0/target/js/browser.maker.js"></script>
<script>window.makerjs = require('makerjs');</script>
<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/",
    "replicad": "./node_modules/replicad/dist/replicad.js"
  }
}
</script>
<script type="module">
import { Horoscope, Origin } from './horoscope-bundle.js';
import { easeInOutCubic, easeOutQuartic } from './modules/easing.js';
import { polygonArea, buildPendantModel } from './modules/pendant-geometry.js';
import { preloadWASM, buildPendant3DFromModel, buildRing3DShape } from './modules/pendant-builder.js';
import { PendantViewer } from './modules/three-pendant-viewer.js';
const m = window.makerjs;

// ── Constants ──────────────────────────────────────────────

const SIGNS = [
  { key: 'aries',       glyph: '\u2648', abbr: 'Ari', element: 'fire' },
  { key: 'taurus',      glyph: '\u2649', abbr: 'Tau', element: 'earth' },
  { key: 'gemini',      glyph: '\u264A', abbr: 'Gem', element: 'air' },
  { key: 'cancer',      glyph: '\u264B', abbr: 'Can', element: 'water' },
  { key: 'leo',         glyph: '\u264C', abbr: 'Leo', element: 'fire' },
  { key: 'virgo',       glyph: '\u264D', abbr: 'Vir', element: 'earth' },
  { key: 'libra',       glyph: '\u264E', abbr: 'Lib', element: 'air' },
  { key: 'scorpio',     glyph: '\u264F', abbr: 'Sco', element: 'water' },
  { key: 'sagittarius', glyph: '\u2650', abbr: 'Sag', element: 'fire' },
  { key: 'capricorn',   glyph: '\u2651', abbr: 'Cap', element: 'earth' },
  { key: 'aquarius',    glyph: '\u2652', abbr: 'Aqu', element: 'air' },
  { key: 'pisces',      glyph: '\u2653', abbr: 'Pis', element: 'water' },
];

const PLANET_KEYS = [
  'sun', 'moon', 'mercury', 'venus', 'mars',
  'jupiter', 'saturn', 'uranus', 'neptune', 'pluto',
];

const PLANET_GLYPHS = {
  sun: '\u2609', moon: '\u263D', mercury: '\u263F', venus: '\u2640',
  mars: '\u2642', jupiter: '\u2643', saturn: '\u2644', uranus: '\u2645',
  neptune: '\u2646', pluto: '\u2647', chiron: '\u26B7', northnode: '\u260A',
  sirius: '\u2605', southnode: '\u260B', lilith: '\u26B8',
};

const PLANET_NAMES = {
  sun: 'Sun', moon: 'Moon', mercury: 'Mercury', venus: 'Venus',
  mars: 'Mars', jupiter: 'Jupiter', saturn: 'Saturn', uranus: 'Uranus',
  neptune: 'Neptune', pluto: 'Pluto',
};

const ASPECT_STYLES = {
  conjunction: { color: '#2c2c2c', width: 1.2, dash: [],     opacity: 0.5 },
  sextile:     { color: '#2c2c2c', width: 0.8, dash: [4, 4], opacity: 0.5 },
  square:      { color: '#2c2c2c', width: 1.2, dash: [],     opacity: 0.35 },
  trine:       { color: '#2c2c2c', width: 1.2, dash: [],     opacity: 0.5 },
  opposition:  { color: '#2c2c2c', width: 1.5, dash: [],     opacity: 0.35 },
};

// ── Aspect Filter Checkboxes ────────────────────────────────

const enabledAspects = new Set(Object.keys(ASPECT_STYLES));
enabledAspects.delete('conjunction');

{
  const container = document.getElementById('aspect-filters');
  for (const [key, style] of Object.entries(ASPECT_STYLES)) {
    const label = document.createElement('label');
    label.className = 'aspect-filter';
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = enabledAspects.has(key);
    cb.dataset.aspect = key;
    cb.addEventListener('change', () => {
      if (cb.checked) enabledAspects.add(key);
      else enabledAspects.delete(key);
      if (displayState) drawChartState(displayState);
    });
    const swatch = document.createElement('span');
    swatch.className = 'swatch';
    swatch.style.background = style.color;
    const name = key.charAt(0).toUpperCase() + key.slice(1);
    label.append(cb, swatch, document.createTextNode(name));
    container.appendChild(label);
  }
}

// ── Canvas Setup ───────────────────────────────────────────

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
const dpr = window.devicePixelRatio || 1;
const SIZE = 700;
canvas.width = SIZE * dpr;
canvas.height = SIZE * dpr;
canvas.style.width = SIZE + 'px';
canvas.style.height = SIZE + 'px';
ctx.scale(dpr, dpr);

const CX = SIZE / 2;
const CY = SIZE / 2;
const OUTER_R = 310;
const ZODIAC_INNER_R = 265;
const ASPECT_R = 265;
const PLANET_R = (OUTER_R + ASPECT_R) / 2;
const PLANET_INNER_R = 205;
const INNER_R = 145;
const PENDANT_R = 100 * (ASPECT_R - 10) / 108; // canvas radius matching pendant's inner circle (r=100, border=8)

// ── State ──────────────────────────────────────────────────

let selectedLat = 38.0464;
let selectedLon = -84.4970;
let chartOpacity = 0.4;
let filletRadius = 5;
let scale3d = 1.0;

// Animation state
let displayState = null;   // what's currently rendered
let fromState = null;      // animation start snapshot
let targetState = null;    // animation target
let animStartTime = null;
let animFrameId = null;
const ANIM_DURATION = 700; // ms

// Stage 2: spread + aspect fade state
let spreadT = 1;              // 0 = exact positions, 1 = fully spread
let spreadAnimId = null;
let spreadAnimStart = null;
const SPREAD_DURATION = 350;  // ms

let aspectAnimId = null;
let aspectAnimStart = null;
let aspectAnimLines = [];   // { d1, d2, style, aspectKey, point1Key, point2Key, delay, duration }
let aspectAnimDone = false;
let showPendantRing = false; // show outer/inner ring from aspect anim onward
const ASPECT_LINE_DURATION = 500; // ms per line
const ASPECT_STAGGER_INITIAL = 100; // ms for first line
const ASPECT_STAGGER_MIN = 25;      // ms minimum stagger at end

// Hover state
let hoveredAspect = null;    // { point1Key, point2Key, aspectKey, tooltipX, tooltipY } or null
let drawnAspects = [];       // cached for hit-testing
const HOVER_THRESHOLD = 6;   // px distance to detect hover

function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx * dx + dy * dy;
  if (lenSq === 0) return Math.hypot(px - x1, py - y1);
  let t = ((px - x1) * dx + (py - y1) * dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
}

canvas.addEventListener('mousemove', (e) => {
  if (!aspectAnimDone || !drawnAspects.length) {
    if (hoveredAspect) { hoveredAspect = null; canvas.style.cursor = ''; drawChartState(displayState); }
    return;
  }
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (SIZE / rect.width);
  const my = (e.clientY - rect.top) * (SIZE / rect.height);

  let closest = null, closestDist = Infinity;
  for (const a of drawnAspects) {
    const d = distToSegment(mx, my, a.x1, a.y1, a.x2, a.y2);
    if (d < closestDist) { closestDist = d; closest = a; }
  }

  const prev = hoveredAspect;
  if (closest && closestDist < HOVER_THRESHOLD) {
    hoveredAspect = { ...closest, tooltipX: mx, tooltipY: my };
    canvas.style.cursor = 'pointer';
  } else {
    hoveredAspect = null;
    canvas.style.cursor = '';
  }

  const changed = (prev?.point1Key !== hoveredAspect?.point1Key ||
                   prev?.point2Key !== hoveredAspect?.point2Key);
  if (changed && displayState) drawChartState(displayState);
});

canvas.addEventListener('mouseleave', () => {
  if (hoveredAspect) {
    hoveredAspect = null;
    canvas.style.cursor = '';
    if (displayState) drawChartState(displayState);
  }
});

// ── Coordinate Helpers ─────────────────────────────────────

function eclToAngle(eclDeg, ascDeg) {
  return (180 - eclDeg + ascDeg) * Math.PI / 180;
}

function eclToXY(eclDeg, radius, ascDeg) {
  const a = eclToAngle(eclDeg, ascDeg);
  return { x: CX + radius * Math.cos(a), y: CY + radius * Math.sin(a) };
}

function normDeg(d) { return ((d % 360) + 360) % 360; }

function lerpAngle(from, to, t) {
  let diff = to - from;
  while (diff > 180) diff -= 360;
  while (diff < -180) diff += 360;
  return normDeg(from + diff * t);
}

// ── Geocoding ──────────────────────────────────────────────

let searchTimeout = null;
const locationInput = document.getElementById('location');
const dropdown = document.getElementById('location-dropdown');
const locationInfo = document.getElementById('location-info');

locationInput.addEventListener('input', () => {
  clearTimeout(searchTimeout);
  const q = locationInput.value.trim();
  if (q.length < 2) { dropdown.classList.remove('open'); return; }
  searchTimeout = setTimeout(() => searchLocation(q), 300);
});

locationInput.addEventListener('blur', () => {
  setTimeout(() => dropdown.classList.remove('open'), 200);
});

async function searchLocation(query) {
  try {
    const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=json&limit=5`;
    const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
    const data = await res.json();
    dropdown.innerHTML = '';
    if (!data.length) {
      dropdown.innerHTML = '<div class="dropdown-item" style="color:#8899aa">No results</div>';
      dropdown.classList.add('open');
      return;
    }
    for (const item of data) {
      const div = document.createElement('div');
      div.className = 'dropdown-item';
      div.textContent = item.display_name;
      div.addEventListener('mousedown', (e) => {
        e.preventDefault();
        selectedLat = parseFloat(item.lat);
        selectedLon = parseFloat(item.lon);
        const name = item.display_name.split(',').slice(0, 2).join(',');
        locationInput.value = name;
        locationInfo.textContent = `${selectedLat.toFixed(4)}°, ${selectedLon.toFixed(4)}°`;
        dropdown.classList.remove('open');
        generateChart();
      });
      dropdown.appendChild(div);
    }
    dropdown.classList.add('open');
  } catch (err) {
    console.error('Geocoding error:', err);
  }
}

// ── Chart State Extraction ─────────────────────────────────

function extractState(h) {
  const ascDeg = getAscendantDeg(h);
  const mcDeg = getMidheavenDeg(h);
  const planets = getBodyPositions(h);
  const cusps = getHouseCusps(h);
  return { ascDeg, mcDeg, planets, cusps, horoscope: h };
}

function lerpState(from, to, t) {
  return {
    ascDeg: lerpAngle(from.ascDeg, to.ascDeg, t),
    mcDeg: (from.mcDeg != null && to.mcDeg != null)
      ? lerpAngle(from.mcDeg, to.mcDeg, t) : to.mcDeg,
    planets: to.planets.map(tp => {
      const fp = from.planets.find(p => p.key === tp.key);
      if (!fp) return tp;
      return { ...tp, deg: lerpAngle(fp.deg, tp.deg, t) };
    }),
    cusps: to.cusps.map((tc, i) => {
      const fc = from.cusps[i];
      if (!fc) return tc;
      return { ...tc, deg: lerpAngle(fc.deg, tc.deg, t) };
    }),
    horoscope: to.horoscope,
  };
}

// ── Chart Generation & Animation ───────────────────────────

const errorEl = document.getElementById('error');

function showError(msg) {
  errorEl.textContent = msg;
  errorEl.style.display = 'block';
  setTimeout(() => { errorEl.style.display = 'none'; }, 5000);
}

function generateChart() {
  errorEl.style.display = 'none';
  if (selectedLat === null) return;

  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const date = parseInt(document.getElementById('birth-day').value);
  const hour = parseInt(document.getElementById('birth-hour').value);
  const minute = parseInt(document.getElementById('birth-minute').value);

  let horoscope;
  try {
    const origin = new Origin({
      year, month: month - 1, date, hour, minute,
      latitude: selectedLat, longitude: selectedLon,
    });
    horoscope = new Horoscope({
      origin,
      houseSystem: 'placidus',
      zodiac: 'tropical',
      aspectPoints: ['all'],
      aspectTypes: ['major'],
      language: 'en',
    });
  } catch (err) {
    console.error('Horoscope error:', err);
    return showError('Error calculating chart. Check inputs.');
  }

  const newState = extractState(horoscope);
  animateTo(newState);
}

function animateTo(newState) {
  // Cancel any in-progress stage 2 animations
  if (spreadAnimId) { cancelAnimationFrame(spreadAnimId); spreadAnimId = null; }
  if (aspectAnimId) { cancelAnimationFrame(aspectAnimId); aspectAnimId = null; }
  if (pendantFadeId) { cancelAnimationFrame(pendantFadeId); pendantFadeId = null; }
  if (expansionAnimId) { cancelAnimationFrame(expansionAnimId); expansionAnimId = null; }
  // Cross-fade 3D back to ring
  if (pendantViewer && chart3dCanvas.style.opacity === '1') {
    buildRing3DShape(100, 8, { thickness: 5, filletR: 2 }).then(ring => {
      if (pendantViewer) pendantViewer.crossFadeMesh(ring.shape, 'high', 400);
    }).catch(() => {});
  }
  spreadT = 0;
  aspectAnimLines = [];
  aspectAnimDone = false;
  pendantAlpha = 0;
  pendantModelData = null;

  // First render — skip stage 1, go straight to stage 2
  if (!displayState) {
    displayState = newState;
    drawChartState(displayState);
    startStage2();
    return;
  }

  // Cancel in-progress position animation
  if (animFrameId) cancelAnimationFrame(animFrameId);

  // Stage 1: animate positions (no spread)
  fromState = { ...displayState };
  targetState = newState;
  animStartTime = null;
  animFrameId = requestAnimationFrame(animStep);
}

function animStep(timestamp) {
  if (!animStartTime) animStartTime = timestamp;
  const elapsed = timestamp - animStartTime;
  const t = Math.min(elapsed / ANIM_DURATION, 1);
  const eased = easeInOutCubic(t);

  displayState = lerpState(fromState, targetState, eased);
  displayState.horoscope = targetState.horoscope;
  drawChartState(displayState);

  if (t < 1) {
    animFrameId = requestAnimationFrame(animStep);
  } else {
    displayState = targetState;
    fromState = null;
    targetState = null;
    animFrameId = null;
    startStage2();
  }
}

// ── Stage 2: Spread then Aspect Fade ────────────────────────

function startStage2() {
  spreadT = 0;
  spreadAnimStart = null;
  spreadAnimId = requestAnimationFrame(spreadStep);
}

function spreadStep(timestamp) {
  if (!spreadAnimStart) spreadAnimStart = timestamp;
  const elapsed = timestamp - spreadAnimStart;
  spreadT = Math.min(elapsed / SPREAD_DURATION, 1);
  spreadT = easeInOutCubic(spreadT);
  drawChartState(displayState);
  if (spreadT < 1) {
    spreadAnimId = requestAnimationFrame(spreadStep);
  } else {
    spreadAnimId = null;
    startAspectAnim();
  }
}

function startAspectAnim() {
  if (aspectAnimId) cancelAnimationFrame(aspectAnimId);
  aspectAnimDone = false;
  aspectAnimStart = null;
  showPendantRing = true;

  // Collect all enabled aspect lines with accelerating stagger
  aspectAnimLines = [];
  if (!displayState?.horoscope) { aspectAnimDone = true; showPendantRing = false; renderPendantOnCanvas(); return; }

  const h = displayState.horoscope;
  const ascDeg = displayState.ascDeg;
  const degMap = {};
  for (const p of displayState.planets) degMap[p.key] = p.deg;

  let aspects = [];
  try {
    if (h.Aspects?.all) aspects = h.Aspects.all;
    else if (Array.isArray(h?.Aspects)) aspects = h.Aspects;
  } catch {}

  // First pass: collect all valid lines
  const collected = [];
  for (const asp of aspects) {
    const key = asp.aspectKey || asp.key || '';
    if (!enabledAspects.has(key)) continue;
    const style = ASPECT_STYLES[key];
    if (!style) continue;
    const d1 = degMap[asp.point1Key];
    const d2 = degMap[asp.point2Key];
    if (d1 === undefined || d2 === undefined) continue;
    collected.push({ d1, d2, style, aspectKey: key, point1Key: asp.point1Key, point2Key: asp.point2Key });
  }

  // Second pass: compute accelerating delays
  let cumDelay = 0;
  const n = collected.length;
  for (let i = 0; i < n; i++) {
    const t = n > 1 ? i / (n - 1) : 0; // 0..1
    const stagger = ASPECT_STAGGER_INITIAL + (ASPECT_STAGGER_MIN - ASPECT_STAGGER_INITIAL) * t;
    aspectAnimLines.push({
      ...collected[i],
      delay: cumDelay,
      duration: ASPECT_LINE_DURATION,
    });
    cumDelay += stagger;
  }

  if (aspectAnimLines.length === 0) {
    aspectAnimDone = true;
    showPendantRing = false;
    renderPendantOnCanvas();
    return;
  }

  aspectAnimId = requestAnimationFrame(aspectAnimStep);
}

function aspectAnimStep(timestamp) {
  if (!aspectAnimStart) aspectAnimStart = timestamp;
  const elapsed = timestamp - aspectAnimStart;

  // Total duration = last line's delay + its duration
  const lastLine = aspectAnimLines[aspectAnimLines.length - 1];
  const totalDuration = lastLine.delay + lastLine.duration;
  const allDone = elapsed >= totalDuration;

  drawChartState(displayState);

  if (!allDone) {
    aspectAnimId = requestAnimationFrame(aspectAnimStep);
  } else {
    aspectAnimId = null;
    aspectAnimDone = true;
    drawChartState(displayState);
    renderPendantOnCanvas();
  }
}

// ── Input Setup & Listeners ─────────────────────────────────

const MONTH_ABBR = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function daysInMonth(year, month) {
  return new Date(year, month, 0).getDate();
}

function updateDayMax() {
  const year = parseInt(document.getElementById('birth-year').value);
  const month = parseInt(document.getElementById('birth-month').value);
  const max = daysInMonth(year, month);
  const daySlider = document.getElementById('birth-day');
  daySlider.max = max;
  if (parseInt(daySlider.value) > max) daySlider.value = max;
  document.getElementById('birth-day-val').textContent = daySlider.value;
}

// Populate hour dropdown (12:00 AM – 11:00 PM)
{
  const hourSel = document.getElementById('birth-hour');
  for (let h = 0; h < 24; h++) {
    const opt = document.createElement('option');
    opt.value = h;
    const display = h === 0 ? '12 AM' : h < 12 ? h + ' AM' : h === 12 ? '12 PM' : (h - 12) + ' PM';
    opt.textContent = display;
    hourSel.appendChild(opt);
  }
  hourSel.value = '12';
}

// Populate minute dropdown (00–59)
{
  const minSel = document.getElementById('birth-minute');
  for (let m = 0; m < 60; m++) {
    const opt = document.createElement('option');
    opt.value = m;
    opt.textContent = String(m).padStart(2, '0');
    minSel.appendChild(opt);
  }
  minSel.value = '0';
}

document.getElementById('birth-year').addEventListener('input', () => {
  document.getElementById('birth-year-val').textContent = document.getElementById('birth-year').value;
  updateDayMax();
  generateChart();
});
document.getElementById('birth-month').addEventListener('input', () => {
  const v = parseInt(document.getElementById('birth-month').value);
  document.getElementById('birth-month-val').textContent = MONTH_ABBR[v - 1];
  updateDayMax();
  generateChart();
});
document.getElementById('birth-day').addEventListener('input', () => {
  document.getElementById('birth-day-val').textContent = document.getElementById('birth-day').value;
  generateChart();
});
document.getElementById('birth-hour').addEventListener('change', generateChart);
document.getElementById('birth-minute').addEventListener('change', generateChart);
document.getElementById('chart-opacity').addEventListener('input', () => {
  const v = parseInt(document.getElementById('chart-opacity').value);
  document.getElementById('chart-opacity-val').textContent = v + '%';
  chartOpacity = v / 100;
  if (displayState) drawChartState(displayState);
});
document.getElementById('fillet-radius').addEventListener('input', () => {
  const v = parseFloat(document.getElementById('fillet-radius').value);
  document.getElementById('fillet-radius-val').textContent = v;
  filletRadius = v;
  if (displayState && pendantChords) {
    const r = 100;
    const exp = pendantExpansion || EXPANSION_TARGET;
    const model = buildPendantModel(pendantChords, exp, r, 8, 185, 5, filletRadius);
    pendantModelData = { model, r, chords: pendantChords };
    pendantAlpha = 1;
    drawChartState(displayState);
  }
});
document.getElementById('scale-3d').addEventListener('input', () => {
  const v = parseInt(document.getElementById('scale-3d').value);
  document.getElementById('scale-3d-val').textContent = v + '%';
  scale3d = v / 100;
  if (pendantViewer && pendantModelData) {
    update3DCamera();
  }
});

// ── Drawing from State ─────────────────────────────────────

function drawChartState(state) {
  const { ascDeg, mcDeg, planets, cusps } = state;
  ctx.clearRect(0, 0, SIZE, SIZE);

  // Show pendant ring (outer + inner border with beige fill between)
  if (showPendantRing) {
    const outerR = ASPECT_R - 10;   // 255
    const innerR = PENDANT_R;        // ~242.86
    ctx.save();
    ctx.beginPath();
    ctx.arc(CX, CY, outerR, 0, Math.PI * 2);
    ctx.arc(CX, CY, innerR, 0, Math.PI * 2, true);
    ctx.fillStyle = '#f5f0e6';
    ctx.fill('evenodd');
    ctx.strokeStyle = '#5a524a';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.arc(CX, CY, outerR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(CX, CY, innerR, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  drawPendant();

  // Chart elements drawn with chartOpacity
  ctx.globalAlpha = chartOpacity;

  // Fill band between outer ring and inner circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2, true);
  ctx.fillStyle = '#f5f0e6';
  ctx.fill();

  // Inner aspect circle
  ctx.beginPath();
  ctx.arc(CX, CY, ASPECT_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#b8b0a2';
  ctx.lineWidth = 0.8;
  ctx.stroke();

  drawZodiacRing(ascDeg);

  const degMap = {};
  for (const p of planets) degMap[p.key] = p.deg;
  drawAspectLines(state.horoscope, degMap, ascDeg);
  drawPlanets(planets, ascDeg);

  ctx.globalAlpha = 1;
}

function getAscendantDeg(h) {
  try { return h.Ascendant.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { try { return h.Houses[0].ChartPosition.StartPosition.Ecliptic.DecimalDegrees; }
  catch { return 0; } }
}

function getMidheavenDeg(h) {
  try { return h.Midheaven.ChartPosition.Ecliptic.DecimalDegrees; }
  catch { return null; }
}

// ── Zodiac Ring ────────────────────────────────────────────

function drawZodiacRing(ascDeg) {
  // Zodiac circle
  ctx.beginPath();
  ctx.arc(CX, CY, OUTER_R, 0, Math.PI * 2);
  ctx.strokeStyle = '#a89f92';
  ctx.lineWidth = 1.2;
  ctx.stroke();

  for (let i = 0; i < 12; i++) {
    const sign = SIGNS[i];
    const startEcl = i * 30;

    // Segment divider line spanning the band
    const p1 = eclToXY(startEcl, OUTER_R, ascDeg);
    const p2 = eclToXY(startEcl, ASPECT_R, ascDeg);
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.strokeStyle = '#a89f92';
    ctx.lineWidth = 0.8;
    ctx.stroke();

    // Sign abbreviation on the outside
    const midEcl = startEcl + 15;
    const glyphPos = eclToXY(midEcl, OUTER_R + 16, ascDeg);
    ctx.font = '10px system-ui, sans-serif';
    ctx.fillStyle = '#8a8078';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(sign.abbr, glyphPos.x, glyphPos.y);
  }
}

// ── Houses ─────────────────────────────────────────────────

function getHouseCusps(h) {
  const cusps = [];
  try {
    for (let i = 0; i < h.Houses.length; i++) {
      const house = h.Houses[i];
      let deg;
      if (house.ChartPosition && house.ChartPosition.StartPosition) {
        deg = house.ChartPosition.StartPosition.Ecliptic.DecimalDegrees;
      } else if (house.ChartPosition && house.ChartPosition.Ecliptic) {
        deg = house.ChartPosition.Ecliptic.DecimalDegrees;
      }
      cusps.push({ id: house.id || (i + 1), deg: normDeg(deg) });
    }
  } catch (err) { console.error('Error reading house cusps:', err); }
  return cusps;
}

// ── Planets ────────────────────────────────────────────────

function getBodyPositions(h) {
  const positions = [];
  const addBody = (body, key) => {
    if (!body || !body.ChartPosition) return;
    const ecl = body.ChartPosition.Ecliptic;
    if (!ecl) return;
    positions.push({
      key,
      deg: normDeg(ecl.DecimalDegrees),
      sign: body.Sign ? body.Sign.key : null,
      signLabel: body.Sign ? body.Sign.label : '',
      house: body.House ? (body.House.id || '') : '',
      retrograde: !!body.isRetrograde,
      arcDeg: ecl.ArcDegrees || null,
      formatted30: ecl.ArcDegreesFormatted30 || '',
    });
  };
  for (const key of PLANET_KEYS) {
    const body = h.CelestialBodies[key] || (h.CelestialPoints && h.CelestialPoints[key]);
    addBody(body, key);
  }
  return positions;
}

function spreadPositions(positions, minGap) {
  // Build items: planets (movable) + sign boundaries (fixed)
  const items = positions.map(p => ({ ...p, displayDeg: p.deg, fixed: false }));
  for (let i = 0; i < 12; i++) {
    items.push({ deg: normDeg(i * 30), displayDeg: normDeg(i * 30), fixed: true, key: '_sign_' + i });
  }

  const n = items.length;
  items.sort((a, b) => a.deg - b.deg);

  // Linearize the circle by breaking at the largest gap
  let maxGap = -1, breakAfter = n - 1;
  for (let i = 0; i < n; i++) {
    const j = (i + 1) % n;
    const gap = normDeg(items[j].deg - items[i].deg);
    if (gap > maxGap) { maxGap = gap; breakAfter = i; }
  }
  const order = [];
  for (let i = 0; i < n; i++) order.push((breakAfter + 1 + i) % n);

  const baseDeg = items[order[0]].deg;
  const truePos = order.map(idx => {
    let d = items[idx].deg - baseDeg;
    if (d < 0) d += 360;
    return d;
  });
  const isFixed = order.map(idx => items[idx].fixed);

  // Layout a group: fixed items stay put, movable items fill around them
  function layoutGroup(g) {
    if (g.count === 1) return [g.truePositions[0]];
    if (!g.fixedFlags.some(f => f)) {
      // All movable: center on mean
      const mean = g.truePositions.reduce((a, b) => a + b) / g.count;
      const start = mean - (g.count - 1) * minGap / 2;
      return g.truePositions.map((_, i) => start + i * minGap);
    }
    // Mixed: two-pass sweep
    const d = g.truePositions.slice();
    // Left-to-right: push movable items right if too close
    for (let i = 1; i < g.count; i++) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    // Right-to-left: pull movable items back toward true position
    for (let i = g.count - 2; i >= 0; i--) {
      if (!g.fixedFlags[i]) {
        d[i] = Math.min(d[i], d[i + 1] - minGap);
        if (i > 0) d[i] = Math.max(d[i], d[i - 1] + minGap);
      }
    }
    return d;
  }

  // Iterative group merging
  let groups = truePos.map((p, i) => ({
    count: 1, truePositions: [p], fixedFlags: [isFixed[i]],
  }));

  let changed = true;
  while (changed) {
    changed = false;
    const merged = [groups[0]];
    for (let i = 1; i < groups.length; i++) {
      const prev = merged[merged.length - 1];
      const curr = groups[i];
      const prevLayout = layoutGroup(prev);
      const currLayout = layoutGroup(curr);
      if (currLayout[0] - prevLayout[prevLayout.length - 1] < minGap) {
        prev.truePositions = prev.truePositions.concat(curr.truePositions);
        prev.fixedFlags = prev.fixedFlags.concat(curr.fixedFlags);
        prev.count += curr.count;
        changed = true;
      } else {
        merged.push(curr);
      }
    }
    groups = merged;
  }

  // Assign display positions
  let itemIdx = 0;
  for (const g of groups) {
    const layout = layoutGroup(g);
    for (let i = 0; i < g.count; i++) {
      items[order[itemIdx]].displayDeg = normDeg(layout[i] + baseDeg);
      itemIdx++;
    }
  }

  return items.filter(p => !p.fixed);
}

function drawPlanets(bodyPositions, ascDeg) {
  const spread = spreadPositions(bodyPositions, 5);

  for (const p of spread) {
    // Interpolate between exact and spread position
    const renderDeg = lerpAngle(p.deg, p.displayDeg, spreadT);

    // Tick mark on inner aspect circle
    const tick1 = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
    const tick2 = eclToXY(p.deg, ASPECT_R - 4, ascDeg);
    ctx.beginPath();
    ctx.moveTo(tick1.x, tick1.y);
    ctx.lineTo(tick2.x, tick2.y);
    ctx.strokeStyle = '#8b8078';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Leader line if spread shifted the glyph
    const offset = Math.abs(normDeg(renderDeg - p.deg));
    if (offset > 1) {
      const from = eclToXY(p.deg, ASPECT_R + 4, ascDeg);
      const to = eclToXY(renderDeg, PLANET_R, ascDeg);
      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = `rgba(139,128,120,${0.3 * spreadT})`;
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }

    // Planet glyph
    const glyphP = eclToXY(renderDeg, PLANET_R, ascDeg);
    ctx.font = '22px system-ui, sans-serif';
    ctx.fillStyle = '#2c2c2c';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(PLANET_GLYPHS[p.key] || p.key[0].toUpperCase(), glyphP.x, glyphP.y);
  }
}

function formatDeg(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30.split("'")[0] + "'";
  if (p.arcDeg) return p.arcDeg.degrees + '°' + p.arcDeg.minutes + "'";
  const inSign = p.deg % 30;
  return Math.floor(inSign) + '°';
}

// ── Aspects ────────────────────────────────────────────────

function drawAspectLines(h, degMap, ascDeg) {
  drawnAspects = [];
  if (aspectAnimLines.length === 0 && !aspectAnimDone) return;

  const elapsed = aspectAnimStart ? performance.now() - aspectAnimStart : Infinity;

  if (aspectAnimDone) {
    // Draw from horoscope data at full length
    let aspects = [];
    try {
      if (h && h.Aspects && h.Aspects.all) aspects = h.Aspects.all;
      else if (Array.isArray(h?.Aspects)) aspects = h.Aspects;
    } catch { return; }

    for (const asp of aspects) {
      const key = asp.aspectKey || asp.key || '';
      if (!enabledAspects.has(key)) continue;
      const style = ASPECT_STYLES[key];
      if (!style) continue;
      const d1 = degMap[asp.point1Key];
      const d2 = degMap[asp.point2Key];
      if (d1 === undefined || d2 === undefined) continue;

      const p1 = eclToXY(d1, PENDANT_R, ascDeg);
      const p2 = eclToXY(d2, PENDANT_R, ascDeg);

      const isHovered = hoveredAspect &&
        hoveredAspect.point1Key === asp.point1Key &&
        hoveredAspect.point2Key === asp.point2Key;

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = style.color;
      ctx.lineWidth = isHovered ? style.width + 2.5 : style.width;
      ctx.setLineDash(style.dash);
      ctx.globalAlpha = isHovered ? 0.95 : style.opacity * chartOpacity;
      ctx.stroke();
      ctx.globalAlpha = chartOpacity;
      ctx.setLineDash([]);

      drawnAspects.push({
        x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
        point1Key: asp.point1Key, point2Key: asp.point2Key,
        aspectKey: key,
      });
    }
  } else {
    // Animating: draw each line with its own progress
    for (const line of aspectAnimLines) {
      const lineElapsed = elapsed - line.delay;
      if (lineElapsed <= 0) continue; // hasn't started yet
      const progress = Math.min(lineElapsed / line.duration, 1);
      const eased = easeOutQuartic(progress);

      const p1 = eclToXY(line.d1, PENDANT_R, ascDeg);
      const p2 = eclToXY(line.d2, PENDANT_R, ascDeg);

      // Draw from p1 toward p2 based on eased progress
      const ex = p1.x + (p2.x - p1.x) * eased;
      const ey = p1.y + (p2.y - p1.y) * eased;

      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(ex, ey);
      ctx.strokeStyle = line.style.color;
      ctx.lineWidth = line.style.width;
      ctx.setLineDash(line.style.dash);
      ctx.globalAlpha = line.style.opacity * chartOpacity;
      ctx.stroke();
      ctx.globalAlpha = chartOpacity;
      ctx.setLineDash([]);

      if (progress >= 1) {
        drawnAspects.push({
          x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y,
          point1Key: line.point1Key, point2Key: line.point2Key,
          aspectKey: line.aspectKey,
        });
      }
    }
  }

  // Draw tooltip for hovered aspect
  if (hoveredAspect && aspectAnimDone) {
    const ha = hoveredAspect;
    const name1 = PLANET_NAMES[ha.point1Key] || ha.point1Key;
    const name2 = PLANET_NAMES[ha.point2Key] || ha.point2Key;
    const label = `Your ${name1} and ${name2} are in ${ha.aspectKey}`;

    ctx.font = '12px system-ui, sans-serif';
    const metrics = ctx.measureText(label);
    const tw = metrics.width + 16;
    const th = 26;
    const tx = ha.tooltipX - tw / 2;
    const ty = ha.tooltipY - th - 10;

    ctx.fillStyle = 'rgba(58,54,48,0.9)';
    ctx.beginPath();
    ctx.roundRect(tx, ty, tw, th, 4);
    ctx.fill();

    ctx.fillStyle = '#f5f0e6';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, ha.tooltipX, ty + th / 2);
  }
}

// ── Angles (AC, MC) ───────────────────────────────────────

function drawAngles(ascDeg, mcDeg) {
  // AC
  const acP = eclToXY(ascDeg, OUTER_R + 5, ascDeg);
  const acI = eclToXY(ascDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(acP.x, acP.y); ctx.lineTo(acI.x, acI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const acL = eclToXY(ascDeg, OUTER_R + 18, ascDeg);
  ctx.font = 'bold 11px system-ui, sans-serif';
  ctx.fillStyle = '#3a3630'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('AC', acL.x, acL.y);

  // DC
  const dcDeg = normDeg(ascDeg + 180);
  const dcP = eclToXY(dcDeg, OUTER_R + 5, ascDeg);
  const dcI = eclToXY(dcDeg, ZODIAC_INNER_R - 2, ascDeg);
  ctx.beginPath(); ctx.moveTo(dcP.x, dcP.y); ctx.lineTo(dcI.x, dcI.y);
  ctx.strokeStyle = '#5a524a'; ctx.lineWidth = 1.5; ctx.stroke();
  const dcL = eclToXY(dcDeg, OUTER_R + 18, ascDeg);
  ctx.fillStyle = '#3a3630';
  ctx.fillText('DC', dcL.x, dcL.y);

  // MC
  if (mcDeg != null) {
    const mcP = eclToXY(mcDeg, OUTER_R + 5, ascDeg);
    const mcI = eclToXY(mcDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(mcP.x, mcP.y); ctx.lineTo(mcI.x, mcI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const mcL = eclToXY(mcDeg, OUTER_R + 18, ascDeg);
    ctx.font = 'bold 11px system-ui, sans-serif';
    ctx.fillStyle = '#5a524a';
    ctx.fillText('MC', mcL.x, mcL.y);

    // IC
    const icDeg = normDeg(mcDeg + 180);
    const icP = eclToXY(icDeg, OUTER_R + 5, ascDeg);
    const icI = eclToXY(icDeg, ZODIAC_INNER_R - 2, ascDeg);
    ctx.beginPath(); ctx.moveTo(icP.x, icP.y); ctx.lineTo(icI.x, icI.y);
    ctx.strokeStyle = '#7a7268'; ctx.lineWidth = 1.5; ctx.stroke();
    const icL = eclToXY(icDeg, OUTER_R + 18, ascDeg);
    ctx.fillText('IC', icL.x, icL.y);
  }
}

// ── Results Table ──────────────────────────────────────────

function populateTable(h) {
  const tbody = document.getElementById('planet-tbody');
  tbody.innerHTML = '';
  const positions = getBodyPositions(h);

  for (const p of positions) {
    const sign = SIGNS.find(s => s.key === p.sign) || SIGNS.find(s => p.sign && s.key.startsWith(p.sign.toLowerCase()));
    const signName = p.signLabel || (sign ? sign.abbr : '');
    const degStr = formatDegFull(p);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${PLANET_NAMES[p.key] || p.key}</td>
      <td>${signName}</td>
      <td>${degStr}</td>`;
    tbody.appendChild(tr);
  }

}

function formatDegFull(p) {
  if (p.formatted30 && p.formatted30 !== "NaN° NaN' NaN''") return p.formatted30;
  if (p.arcDeg) return p.arcDeg.degrees + '° ' + p.arcDeg.minutes + "' " + (p.arcDeg.seconds || 0) + "''";
  const inSign = p.deg % 30;
  const d = Math.floor(inSign);
  const m = Math.floor((inSign - d) * 60);
  return d + '° ' + m + "'";
}

// ── MakerJS Pendant Build ──────────────────────────────────

let pendantModelData = null; // cached MakerJS model for drawing on canvas
let pendantAlpha = 0;
let pendantFadeId = null;
let pendantFadeStart = null;
const PENDANT_FADE_DURATION = 500;

function computeChords(planetAngles, aspectAngles, orb) {
  const lines = [];
  for (let i = 0; i < planetAngles.length; i++) {
    for (let j = i + 1; j < planetAngles.length; j++) {
      let diff = Math.abs(planetAngles[i] - planetAngles[j]);
      if (diff > 180) diff = 360 - diff;
      for (const asp of aspectAngles) {
        if (Math.abs(diff - asp) <= orb) {
          lines.push({
            a1: planetAngles[i] * Math.PI / 180,
            a2: planetAngles[j] * Math.PI / 180,
          });
          break;
        }
      }
    }
  }
  return lines;
}

function buildPendantFromChart(horoscope, ascDeg, expansion) {
  // Build planet angle lookup (chart-rotated)
  const planetAngles = {};
  for (const key of PLANET_KEYS) {
    const body = horoscope.CelestialBodies[key] || (horoscope.CelestialPoints && horoscope.CelestialPoints[key]);
    if (body?.ChartPosition?.Ecliptic) {
      const ecl = body.ChartPosition.Ecliptic.DecimalDegrees;
      planetAngles[key] = normDeg(180 - ecl + ascDeg) * Math.PI / 180;
    }
  }

  // Use the exact same aspects the horoscope library computed
  let aspects = [];
  try {
    if (horoscope.Aspects?.all) aspects = horoscope.Aspects.all;
    else if (Array.isArray(horoscope.Aspects)) aspects = horoscope.Aspects;
  } catch {}

  const chords = [];
  for (const asp of aspects) {
    const key = asp.aspectKey || asp.key || '';
    if (!enabledAspects.has(key)) continue;
    const a1 = planetAngles[asp.point1Key];
    const a2 = planetAngles[asp.point2Key];
    if (a1 === undefined || a2 === undefined) continue;
    chords.push({ a1, a2 });
  }
  if (chords.length === 0) return null;

  const r = 100;
  const model = buildPendantModel(chords, expansion, r, 8, 185, 5, filletRadius);
  return { model, r, chords };
}

let pendantChords = null;  // cached chords for thickness animation
let pendantExpansion = 0;
const EXPANSION_TARGET = 3;
const EXPANSION_STEP = 0.3;
const EXPANSION_DURATION = 2000; // ms
let expansionAnimId = null;
let expansionAnimStart = null;

function renderPendantOnCanvas() {
  if (!displayState?.horoscope) return;
  try {
    // Build once at target expansion to extract chords, then animate from 0
    const result = buildPendantFromChart(displayState.horoscope, displayState.ascDeg, EXPANSION_TARGET);
    if (!result) { pendantModelData = null; return; }
    pendantChords = result.chords;
    pendantExpansion = 0;
    pendantAlpha = 1;
    startExpansionAnim();
  } catch (err) {
    console.error('Pendant build error:', err);
    pendantModelData = null;
  }
}

function startExpansionAnim() {
  if (expansionAnimId) cancelAnimationFrame(expansionAnimId);
  expansionAnimStart = null;
  expansionAnimId = requestAnimationFrame(expansionStep);
}

function expansionStep(timestamp) {
  if (!pendantChords || !displayState) return;
  if (!expansionAnimStart) expansionAnimStart = timestamp;
  const elapsed = timestamp - expansionAnimStart;
  const t = Math.min(elapsed / EXPANSION_DURATION, 1);
  const eased = easeOutQuartic(t);

  // Quantize to step grid
  const rawExp = EXPANSION_STEP + eased * (EXPANSION_TARGET - EXPANSION_STEP);
  const quantized = Math.min(Math.round(rawExp / EXPANSION_STEP) * EXPANSION_STEP, EXPANSION_TARGET);

  // Only rebuild if expansion changed
  if (quantized !== pendantExpansion) {
    pendantExpansion = quantized;
    try {
      const r = 100;
      const model = buildPendantModel(pendantChords, pendantExpansion, r, 8, 185, 5, filletRadius);
      pendantModelData = { model, r, chords: pendantChords };
      drawChartState(displayState);
    } catch {}
  }

  if (t < 1) {
    expansionAnimId = requestAnimationFrame(expansionStep);
  } else {
    expansionAnimId = null;
    start3DTransition();
  }
}

function startPendantFade() {
  if (pendantFadeId) cancelAnimationFrame(pendantFadeId);
  pendantAlpha = 0;
  pendantFadeStart = null;
  pendantFadeId = requestAnimationFrame(pendantFadeStep);
}

function pendantFadeStep(timestamp) {
  if (!pendantFadeStart) pendantFadeStart = timestamp;
  const elapsed = timestamp - pendantFadeStart;
  pendantAlpha = Math.min(elapsed / PENDANT_FADE_DURATION, 1);
  if (displayState) drawChartState(displayState);
  if (pendantAlpha < 1) {
    pendantFadeId = requestAnimationFrame(pendantFadeStep);
  } else {
    pendantFadeId = null;
  }
}

function drawPendant() {
  if (!pendantModelData || pendantAlpha <= 0) return;
  const { model, r } = pendantModelData;
  const b = 8; // borderThickness used in buildPendantModel
  const outerR = r + b;

  // Fit the model inside the inner circle
  const drawR = ASPECT_R - 10;
  const scale = drawR / outerR;

  ctx.save();
  ctx.beginPath();
  ctx.arc(CX, CY, ASPECT_R - 2, 0, Math.PI * 2);
  ctx.clip();
  ctx.globalAlpha = pendantAlpha;
  ctx.translate(CX, CY);
  ctx.scale(scale, scale);

  // Find cutout regions from chains
  const fillChains = m.model.findChains(model);
  const circleArea = Math.PI * r * r;
  const cutouts = [];
  for (const ch of fillChains) {
    if (!ch.endless) continue;
    try {
      const pts = m.chain.toKeyPoints(ch, 1);
      if (pts.length < 3) continue;
      const area = polygonArea(pts);
      if (area >= circleArea * 0.95) continue;
      cutouts.push(pts);
    } catch {}
  }

  // Fill pendant material with beige, cutouts left transparent (grid shows through)
  ctx.beginPath();
  ctx.arc(0, 0, outerR, 0, Math.PI * 2);
  for (const pts of cutouts) {
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j][0], pts[j][1]);
    ctx.closePath();
  }
  ctx.fillStyle = '#f5f0e6';
  ctx.fill('evenodd');

  // Stroke the outer border and cutout outlines
  ctx.strokeStyle = '#5a524a';
  ctx.lineWidth = 1.0 / scale;
  ctx.beginPath();
  ctx.arc(0, 0, outerR, 0, Math.PI * 2);
  ctx.stroke();
  for (const pts of cutouts) {
    ctx.beginPath();
    ctx.moveTo(pts[0][0], pts[0][1]);
    for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j][0], pts[j][1]);
    ctx.closePath();
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.restore();
}

// ── 3D Transition ──────────────────────────────────────────

const chart3dCanvas = document.getElementById('chart-3d');
let pendantViewer = null;
let wasmPromise = null;

// Start WASM download early — runs concurrently with 2D animations
try { wasmPromise = preloadWASM(); } catch(e) { console.warn('WASM preload failed:', e); }

// Compute orthographic half-size so 3D model matches 2D canvas sizing
function compute3DHalf() {
  const outerR = (pendantModelData?.r || 100) + 8;
  const drawR = ASPECT_R - 10; // 255 canvas pixels for the pendant
  const canvasHalf = SIZE / 2;  // 350 canvas pixels for the half-width
  return (canvasHalf / drawR) * outerR;
}

function update3DCamera() {
  if (!pendantViewer || !pendantModelData) return;
  const outerR = pendantModelData.r + 8;
  pendantViewer.fitToRegionExact(compute3DHalf(), outerR);
  // Scale model instead of camera so lighting stays consistent
  pendantViewer.pendantGroup.scale.setScalar(scale3d);
  pendantViewer.setShadowPlaneY(-7);
}

async function ensureViewer() {
  if (pendantViewer) return;
  const THREE = await import("three");
  pendantViewer = new PendantViewer(chart3dCanvas, {
    enableControls: false,
    enableEdges: false,
    enableGroundPlane: false,
    enableHDRI: true,
    hdriPath: './softbox.hdr',
    enablePostProcessing: true,
    background: null,
    roughness: 0,
  });
  pendantViewer.scene.background = null;

  // Rotate lights and HDRI to match the angle found at (106.6, 296.3, 16.7)
  const fromDir = new THREE.Vector3(-106.6, -301.3, -16.7).normalize();
  const toDir = new THREE.Vector3(0, -1, 0);
  const q = new THREE.Quaternion().setFromUnitVectors(fromDir, toDir);
  pendantViewer.scene.traverse(obj => {
    if (obj.isLight) obj.position.applyQuaternion(q);
  });
  if (pendantViewer.scene.environmentRotation !== undefined) {
    pendantViewer.scene.environmentRotation = new THREE.Euler().setFromQuaternion(q);
  }

  pendantViewer.addShadowPlane(-7);
  pendantViewer.start();
}

async function start3DTransition() {
  if (!pendantModelData?.model) return;
  try {
    if (wasmPromise) await wasmPromise;
    await ensureViewer();

    const r = pendantModelData.r;
    const opts = { thickness: 5, filletR: 2 };

    if (chart3dCanvas.style.opacity !== '1') {
      // First load — show ring instantly, then cross-fade to full
      const ring = await buildRing3DShape(r, 8, opts);
      pendantViewer.updateMesh(ring.shape, 'high');
      update3DCamera();
      chart3dCanvas.style.opacity = '1';
    }

    // Build full pendant, then cross-fade from whatever is showing (ring)
    const full = await buildPendant3DFromModel(pendantModelData.model, r, 8, opts);
    pendantViewer.crossFadeMesh(full.shape, 'high', 800);
  } catch (err) {
    console.error('3D transition error:', err);
  }
}

// ── Boot ───────────────────────────────────────────────────

generateChart();

</script>
</body>
</html>
